<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">

        <title>计算复杂性 (Computational Complexity) 与动态规划 (Dynamic Programming) - Zeqiang Fang | 方泽强</title>

    <meta name="referrer" content="no-referrer">
    
    <meta property="og:title" content="计算复杂性 (Computational Complexity) 与动态规划 (Dynamic Programming) - Zeqiang Fang | 方泽强">
    <meta name="description" property="og:description" content="计算复杂性 计算复杂性 (Computational Complexity) 是用于对一个问题求解所需的资源 (通常为 空间 和 时间) 的度量。在评估一个算法的时候，除了算法本身的准确性以外，同时需要关">
    <meta property="og:type" content="article">
    <meta property="og:site_name" content="Zeqiang Fang | 方泽强">
    <meta property="og:url" content="https://leovan.me/cn/2018/11/computational-complexity-and-dynamic-programming/">

    
    
    
    
    <meta name="author" property="article:author" content="范叶亮">
    
    
    
    <meta name="date" property="article:published_time" content="2018-11-18" scheme="YYYY-MM-DD">
    
    
    <meta name="date" property="article:modified_time" content="2018-11-18" scheme="YYYY-MM-DD">
    

    
    <meta name="keywords" property="article:tag" content ="计算复杂性,Computational Complexity,函数的增长,P 问题,NP 问题,NP Complete 问题,NP Hard 问题,动态规划,Dynamic Programming,背包问题,Knapsack Problem,最长公共子序列,Longest Common Subsequence,最长公共子串,Longest Common Substring,最短路问题,Shortest Path Problem,Floyd-Warshall 算法">
    
    
    <meta name="theme-color" content="#0d0d0d">
    
    <link rel="icon" type="image/png" sizes="16x16" href="/images/web/favicon-16x16.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/images/web/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="48x48" href="/images/web/favicon-48x48.png">
    <link rel="icon" type="image/png" sizes="62x62" href="/images/web/favicon-62x62.png">
    <link rel="icon" type="image/png" sizes="192x192" href="/images/web/favicon-192x192.png">
    <link rel="apple-touch-icon" size="192x192" href="/images/web/icon-192x192.png">
    <link rel="manifest" href="/manifest.json">
        
    

    

    <script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https://leovan.me/cn"
        },
        "name": "计算复杂性 (Computational Complexity) 与动态规划 (Dynamic Programming)",
        "headline": "计算复杂性 (Computational Complexity) 与动态规划 (Dynamic Programming)",
        "description" : "计算复杂性 计算复杂性 (Computational Complexity) 是用于对一个问题求解所需的资源 (通常为 空间 和 时间) 的度量。在评估一个算法的时候，除了算法本身的准确性以外，同时需要关",
        "genre": [
            "最优化"
        ],
        "datePublished": "2018-11-18",
        "dateModified": "2018-11-18",
        "wordCount": "5145",
        "keywords": [
            "计算复杂性", "Computational Complexity", "函数的增长", "P 问题", "NP 问题", "NP Complete 问题", "NP Hard 问题", "动态规划", "Dynamic Programming", "背包问题", "Knapsack Problem", "最长公共子序列", "Longest Common Subsequence", "最长公共子串", "Longest Common Substring", "最短路问题", "Shortest Path Problem", "Floyd-Warshall 算法"
        ],
        "image": [
            "https://leovan.me/images/cn/2018-11-18-computational-complexity-and-dynamic-programming/shortest-path.png"
        ],
        "author": {
            "@type": "Person",
            "name": "范叶亮"
        },
        "publisher": {
            "@type": "Organization",
            "name": "范叶亮",
            "logo": {
                "@type": "ImageObject",
                "url": "https://leovan.me/images/web/publisher-logo.png"
            }
        },
        "url": "https://leovan.me/cn/2018/11/computational-complexity-and-dynamic-programming/"
    }
    </script>
    

    <script src='//cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js'></script>
<script src='//cdnjs.cloudflare.com/ajax/libs/js-cookie/2.2.1/js.cookie.min.js'></script>

<link rel="stylesheet" type="text/css" href="//cdnjs.cloudflare.com/ajax/libs/MaterialDesign-Webfont/6.5.95/css/materialdesignicons.min.css">





<link rel="stylesheet" type="text/css" href="//cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism.min.css">

<link rel="stylesheet" type="text/css" href="//cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/themes/prism-.min.css">





<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<link rel="stylesheet" type="text/css" href="/css/fonts.css" />
<link rel="stylesheet" type="text/css" href="/css/style.css">
<link rel="stylesheet" type="text/css" href="/css/light.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" id="dark-mode-style" disabled="disabled">
<link rel="stylesheet" type="text/css" href="/css/icons.css">
<link rel="stylesheet" type="text/css" href="/css/print.css">

  </head>

  
  <body class="cn">
    <header class="masthead">
      

<div class="logo"></div>
<p class="slogan">优雅永不过时</p>
      <nav class="menu">
  <ul>
  
  
  
    
  
  
    <li><a href="/">首页</a></li>
  
    <li><a href="/cn/">博客</a></li>
  
    <li><a href="/categories/">分类</a></li>
  
    <li class="menu-separator"><span>&nbsp;</span></li>
  
    <li><a href="/cn/about/">关于</a></li>
  
    <li><a href="/cn/resume/">简历</a></li>
  
  


<li class="menu-separator"><span>&nbsp;</span></li>

<li><a href="/cn/index.xml" target="_blank" type="application/rss+xml" title="RSS feed">订阅</a></li>

<li><a href="https://github.com/fang-zeqiang/fang-zeqiang.github.io/blob/master/LICENSE" target="_blank" title="Attribution-NonCommercial-ShareAlike 4.0 International">版权</a></li>


  <li class="light-dark-mode no-border-bottom"><a id="light-dark-mode-action"><span id="light-dark-mode-icon" class="mdi mdi-weather-night"></span></a></li>
  </ul>
</nav>

      <script src="/js/toggle-theme.js"></script>
    </header>

    <article class="main">
      <header class="title">
      
<h1>计算复杂性 (Computational Complexity) 与动态规划 (Dynamic Programming)</h1>







<h3>范叶亮 / 
2018-11-18</h3>



<h3 class="post-meta">


<strong>分类: </strong>
<a href="/categories/%E6%9C%80%E4%BC%98%E5%8C%96">最优化</a>




/




<strong>标签: </strong>
<span>计算复杂性</span>, <span>Computational Complexity</span>, <span>函数的增长</span>, <span>P 问题</span>, <span>NP 问题</span>, <span>NP Complete 问题</span>, <span>NP Hard 问题</span>, <span>动态规划</span>, <span>Dynamic Programming</span>, <span>背包问题</span>, <span>Knapsack Problem</span>, <span>最长公共子序列</span>, <span>Longest Common Subsequence</span>, <span>最长公共子串</span>, <span>Longest Common Substring</span>, <span>最短路问题</span>, <span>Shortest Path Problem</span>, <span>Floyd-Warshall 算法</span>




/


<strong>字数: </strong>
5145
</h3>



<hr>


      </header>






<h2 id="计算复杂性">计算复杂性</h2>

<p><strong>计算复杂性 (Computational Complexity)</strong> 是用于对一个问题求解所需的资源 (通常为 <strong>空间</strong> 和 <strong>时间</strong>) 的度量。在评估一个算法的时候，除了算法本身的准确性以外，同时需要关注算法运行的时间以及占用的内存，从而根据实际情况选择合适的算法。</p>

<h3 id="函数的增长">函数的增长</h3>

<p>计算复杂性中的空间和时间的评估方法类似，在此我们更多的以时间复杂度为例。算法的运行时间刻画了算法的效率，对于一个输入规模为 <code>$n$</code> 的问题，定义一个算法求解该问题 <strong>最坏情况</strong> 下的运行时间为 <code>$T \left(n\right)$</code>，我们可以使用一些 <strong>渐进记号</strong> 更加方便地对其进行描述。</p>

<ul>
<li><strong><code>$\Theta$</code> 记号</strong></li>
</ul>

<p>对于一个给定的函数 <code>$g \left(n\right)$</code>，<code>$\Theta \left(g \left(n\right)\right)$</code> 可以表示如下函数的集合：</p>

<p><code>$$
\Theta \left(g \left(n\right)\right) = \left\{f \left(n\right): \exists c_1 &gt; 0, c_2 &gt; 0, n_0 &gt; 0, s.t. \forall n \geq n_0, 0 \leq c_1 g \left(n\right) \leq f \left(n\right) \leq c_2 g \left(n\right) \right\}
$$</code></p>

<p>也就是说当 <code>$n$</code> 足够大时，函数 <code>$f \left(n\right)$</code> 能够被 <code>$c_1 g \left(n\right)$</code> 和 <code>$c_2 g \left(n\right)$</code> 夹在中间，我们称 <code>$g \left(n\right)$</code> 为 <code>$f \left(n\right)$</code> 的一个 <strong>渐进紧确界 (Asymptotically Tight Bound)</strong>。</p>

<ul>
<li><strong><code>$O$</code> 记号</strong></li>
</ul>

<p><code>$\Theta$</code> 记号给出了一个函数的上界和下界，当只有一个 <strong>渐进上界</strong> 时，可使用 <code>$O$</code> 记号。<code>$O \left(g \left(n\right)\right)$</code> 表示的函数集合为：</p>

<p><code>$$
O \left(g \left(n\right)\right) = \left\{f \left(n\right): \exists c &gt; 0, n_0 &gt; 0, s.t. \forall n \geq n_0, 0 \leq f \left(n\right) \leq c g \left(n\right)\right\}
$$</code></p>

<p><code>$O$</code> 记号描述的为函数的上界，因此可以用它来限制算法在最坏情况下的运行时间。</p>

<ul>
<li><strong><code>$\Omega$</code> 记号</strong></li>
</ul>

<p><code>$\Omega$</code> 记号提供了 <strong>渐进下界</strong>，其表示的函数集合为：</p>

<p><code>$$
\Omega \left(g \left(n\right)\right) = \left\{f \left(n\right): \exists c &gt; 0, n_0 &gt; 0, s.t. \forall n \geq n_0, 0 \leq c g \left(n\right) \leq f \left(n\right)\right\}
$$</code></p>

<p>根据上面的三个渐进记号，不难证明如下定理：</p>

<div class="blockquote" style='border-left: 4px solid #369BE5;'><strong>定理 1</strong> 对于任意两个函数 <code>$f \left(n\right)$</code> 和 <code>$g \left(n\right)$</code>，有 <code>$f \left(n\right) = \Theta \left(g \left(n\right)\right)$</code>，当且仅当 <code>$f \left(n\right) = O \left(g \left(n\right)\right)$</code> 且 <code>$f \left(n\right) = \Omega \left(g \left(n\right)\right)$</code>。</div>

<ul>
<li><strong><code>$o$</code> 记号</strong></li>
</ul>

<p><code>$O$</code> 记号提供的渐进上界可能是也可能不是渐进紧确的，例如 <code>$2n^2 = O \left(n^2\right)$</code> 是渐进紧确的，但 <code>$2n = O \left(n^2\right)$</code> 是非渐进紧确的。我们使用 <code>$o$</code> 记号表示非渐进紧确的上界，其表示的函数集合为：</p>

<p><code>$$
o \left(g \left(n\right)\right) = \left\{f \left(n\right): \forall c &gt; 0, \exists n_0 &gt; 0, s.t. \forall n \geq n_0, 0 \leq f \left(n\right) &lt; c g \left(n\right)\right\}
$$</code></p>

<ul>
<li><strong><code>$\omega$</code> 记号</strong></li>
</ul>

<p><code>$\omega$</code> 记号与 <code>$\Omega$</code> 记号的关系类似于 <code>$o$</code> 记号与 <code>$O$</code> 记号的关系，我们使用 <code>$\omega$</code> 记号表示一个非渐进紧确的下界，其表示的函数集合为：</p>

<p><code>$$
\omega \left(g \left(n\right)\right) = \left\{f \left(n\right): \forall c &gt; 0, \exists n_0 &gt; 0, s.t. \forall n \geq n_0, 0 \leq c g \left(n\right) &lt; f \left(n\right)\right\}
$$</code></p>

<h3 id="np-完全性">NP 完全性</h3>

<p>计算问题可以按照在不同计算模型下所需资源的不同予以分类，从而得到一个对算法问题“难度”的类别，这就是复杂性理论中复杂性类概念的来源 <sup class="footnote-ref" id="fnref:wikipedia-computational-complexity-theory"><a href="#fn:wikipedia-computational-complexity-theory">1</a></sup>。对于输入规模为 <code>$n$</code> 的问题，一个算法在最坏情况下的运行时间为 <code>$O \left(n^k\right)$</code>，其中 <code>$k$</code> 为一个确定的常数，我们称这类算法为 <strong>多项式时间的算法</strong>。</p>

<p>本节我们将介绍四类问题：P 类问题，NP 类问题，NPC 类问题和 NPH 类问题。</p>

<ul>
<li><strong>P 类问题</strong></li>
</ul>

<p>P 类问题 (Polynomial Problem，多项式问题) 是指能在多项式时间内 <strong>解决</strong> 的问题。</p>

<ul>
<li><strong>NP 类问题</strong></li>
</ul>

<p>NP 类问题 (Non-Deteministic Polynomial Problem，非确定性多项式问题) 是指能在多项式时间内被 <strong>证明</strong> 的问题，也就是可以在多项式时间内对于一个给定的解验证其是否正确。所有的 P 类问题都是 NP 类问题，但目前 (截至 2018 年，下文如不做特殊说明均表示截至到该时间) 人类还未证明 <code>$P \neq NP$</code> 还是 <code>$P = NP$</code>。</p>

<ul>
<li><strong>NPC 类问题 (NP-Complete Problems)</strong></li>
</ul>

<p>在理解 NPC 类问题之前，我们需要引入如下几个概念：</p>

<ol>
<li><strong>最优化问题 (Optimization Problem)</strong> 与 <strong>判定问题 (Decision Problem)</strong>：最优化问题是指问题的每一个可行解都关联一个值，我们希望找到具有最佳值的可行解。判定问题是指问题的答案仅为“是”或“否”的问题。NP 完全性仅适用于判定问题，但通过对最优化问题强加一个界，可以将其转换为判定问题。</li>
<li><strong>归约 (Reduction)</strong>：假设存在一个判定问题 A，该问题的输入称之为实例，我们希望能够在多项式时间内解决该问题。假设存在另一个不同的判定问题 B，并且已知能够在多项式时间内解决该问题，同时假设存在一个过程，它可以将 A 的任何实例 <code>$\alpha$</code> 转换成 B 的某个实例 <code>$\beta$</code>，转换操作需要在多项式时间内完成，同时两个实例的解是相同的。则我们称这一过程为多项式 <strong>规约算法 (Reduction Algorithm)</strong>。通过这个过程，我们可以将问题 A 的求解“归约”为对问题 B 的求解，从而利用问题 B 的“易求解性”来证明 A 的“易求解性”。</li>
</ol>

<p>从而我们可以定义 NPC 类问题为：首先 NPC 类问题是一个 NP 类问题，其次所有的 NP 类问题都可以用多项式时间归约到这类问题。因此，只要找到 NPC 类问题的一个多项式时间的解，则所有的 NP 问题都可以通过多项式时间归约到该问题，并用多项式时间解决该问题，从而使得 <code>$NP = P$</code>，但目前，NPC 类问题并没有找到一个多项式时间的算法。</p>

<ul>
<li><strong>NPH 类问题 (NP-Hard Problems)</strong></li>
</ul>

<p>NPH 类问题定义为所有的 NP 类问题都可以通过多项式时间归约到这类问题，但 NPH 类问题不一定是 NP 类问题。NPH 类问题同样很难找到多项式时间的解，由于 NPH 类问题相比较 NPC 类问题放松了约束，因此即便 NPC 类问题找到了多项式时间的解，NPH 类问题仍可能无法在多项式时间内求解。</p>

<p>下图分别展示了 <code>$P \neq NP$</code> 和 <code>$P = NP$</code> 两种假设情况下四类问题之间的关系：</p>

<p><img src="/images/cn/2018-11-18-computational-complexity-and-dynamic-programming/p-np-np-complete-np-hard.svg" alt="" /></p>

<h2 id="动态规划">动态规划</h2>

<p><strong>动态规划 (Dynamic Programming, DP)</strong> 算法通常基于一个递归公式和一个或多个初始状态，并且当前子问题的解可以通过之前的子问题构造出来。动态规划算法求解问题的时间复杂度仅为多项式复杂度，相比其他解法，例如：回溯法，暴利破解法所需的时间要少。动态规划中的 “Programming” 并非表示利用计算机编程，而是一种表格法。动态规划对于每个子问题只求解一次，将解保存在一个表格中，从而避免不必要的重复计算。</p>

<p>动态规划算法的适用情况如下 <sup class="footnote-ref" id="fnref:wikipedia-dynamic-programming"><a href="#fn:wikipedia-dynamic-programming">2</a></sup>：</p>

<ol>
<li><strong>最优子结构性质</strong>，即问题的最优解由相关子问题的最优解组合而成，子问题可以独立求解。</li>
<li><strong>无后效性</strong>，即每个状态均不会影响之前的状态。</li>
<li><strong>子问题重叠性质</strong>，即在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。</li>
</ol>

<p>一个动态规划算法的核心包含两个部分：<strong>状态</strong> 和 <strong>状态转移方程</strong>。状态即一个子问题的表示，同时这个表示需要具备 <strong>无后效性</strong>。状态转移方程用于描述状态之间的关系，也就是如何利用之前的状态构造出当前的状态进而求解。</p>

<p>动态规划有两种等价的实现方法：</p>

<ol>
<li><strong>带备忘的自顶向下法 (Top-Down with Memoization)</strong>，该方法采用自然的递归形式编写过程，但会保留每个子问题的解，当需要一个子问题的解时会先检查是否保存过，如果有则直接返回该结果。</li>
<li><strong>自底向上法 (Bottom-Up Method)</strong>，该方法需要恰当的定义子问题“规模”，任何子问题的求解都值依赖于“更小”的子问题的求解，从而可以按照子问题的规模从小到大求解。</li>
</ol>

<p>两种方法具有相同的渐进运行时间，在某些特殊的情况下，自顶向下的方法并未真正递归地考虑所有可能的子问题；自底向上的方法由于没有频繁的递归调用，时间复杂性函数通常具有更小的系数。</p>

<h3 id="背包问题">背包问题</h3>

<p><strong>背包问题 (Knapsack problem)</strong> 是一种组合优化的 NPC 类问题。问题可以描述为：给定一组物品，每种物品都有自己的重量和价值，在限定的总重量内，合理地选择物品使得总价值最高。</p>

<p>形式化的定义，我们有 <code>$n$</code> 种物品，物品 <code>$j$</code> 的重量为 <code>$w_j$</code>，价值为 <code>$p_j$</code>，假定所有物品的重量和价值都是非负的，背包所能承受的最大重量为 <code>$W$</code>。如果限定每种物品只能选择 0 个或 1 个，则该问题称为 <strong>0-1 背包问题</strong>；如果限定物品 <code>$j$</code> 最多只能选择 <code>$b_j$</code> 个，则该问题称为 <strong>有界背包问题</strong>；如果不限定每种物品的数量，则该问题称为 <strong>无界背包问题</strong>。最优化问题可以表示为：</p>

<p><code>$$
\begin{equation}
\begin{split}
\text{maximize} &amp; \sum_{j=1}^{n}{p_j x_j} \\
s.t. &amp; \sum_{j=1}^{n}{w_j x_j} \leq W, x_j \in \left\{0, 1, ..., b_j\right\}
\end{split}
\end{equation}
$$</code></p>

<p>以 0-1 背包问题为例，用 <code>$d_{i, w}$</code> 表示取 <code>$i$</code> 件商品填充一个最大承重 <code>$w$</code> 的背包的最大价值，问题的最优解即为 <code>$d_{n, W}$</code>。不难写出 0-1 背包问题的状态转移方程如下：</p>

<p><code>$$
d_{i, w} = 
\begin{cases}
d_{i - 1, w}, &amp; w &lt; w_i \\
\max \left(d_{i - 1, w}, d_{i - 1, w - w_i} + p_i\right), &amp; w \geq w_i \\
0, &amp; i w = 0
\end{cases}
$$</code></p>

<p>一个 0-1 背包问题的具体示例如下：背包承受的最大重量 <code>$W = 10$</code>，共有 <code>$n = 5$</code> 种物品，编号分别为 <code>$A, B, C, D, E$</code>，重量分别为 <code>$2, 2, 6, 5, 4$</code>，价值分别为 <code>$6, 3, 5, 4, 6$</code>，利用 BP 求解该问题，不同 <code>$i, w$</code> 情况下的状态如下表所示 (计算过程详见 <a href="https://github.com/leovan/leovan.me/tree/master/scripts/cn/2018-11-18-computational-complexity-and-dynamic-programming/0-1-knapsack-dp.py" rel="noreferrer" target="_blank">这里</a>)：</p>

<table>
<thead>
<tr>
<th align="center">i \ w</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
<th align="center">8</th>
<th align="center">9</th>
<th align="center">10</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">1</td>
<td align="center">NA</td>
<td align="center">(A) <br/> 2 - 6</td>
<td align="center">(A) <br/> 2 - 6</td>
<td align="center">(A) <br/> 2 - 6</td>
<td align="center">(A) <br/> 2 - 6</td>
<td align="center">(A) <br/> 2 - 6</td>
<td align="center">(A) <br/> 2 - 6</td>
<td align="center">(A) <br/> 2 - 6</td>
<td align="center">(A) <br/> 2 - 6</td>
<td align="center">(A) <br/> 2 - 6</td>
</tr>

<tr>
<td align="center">2</td>
<td align="center">NA</td>
<td align="center">(A) <br/> 2 - 6</td>
<td align="center">(A) <br/> 2 - 6</td>
<td align="center">(A, B) <br/> 4 - 9</td>
<td align="center">(A, B) <br/> 4 - 9</td>
<td align="center">(A, B) <br/> 4 - 9</td>
<td align="center">(A, B) <br/> 4 - 9</td>
<td align="center">(A, B) <br/> 4 - 9</td>
<td align="center">(A, B) <br/> 4 - 9</td>
<td align="center">(A, B) <br/> 4 - 9</td>
</tr>

<tr>
<td align="center">3</td>
<td align="center">NA</td>
<td align="center">(A) <br/> 2 - 6</td>
<td align="center">(A) <br/> 2 - 6</td>
<td align="center">(A, B) <br/> 4 - 9</td>
<td align="center">(A, B) <br/> 4 - 9</td>
<td align="center">(A, B) <br/> 4 - 9</td>
<td align="center">(A, B) <br/> 4 - 9</td>
<td align="center">(A, C) <br/> 8 - 11</td>
<td align="center">(A, C) <br/> 8 - 11</td>
<td align="center">(A, B, C) <br/> 10 - 14</td>
</tr>

<tr>
<td align="center">4</td>
<td align="center">NA</td>
<td align="center">(A) <br/> 2 - 6</td>
<td align="center">(A) <br/> 2 - 6</td>
<td align="center">(A, B) <br/> 4 - 9</td>
<td align="center">(A, B) <br/> 4 - 9</td>
<td align="center">(A, B) <br/> 4 - 9</td>
<td align="center">(A, D) <br/> 7 - 10</td>
<td align="center">(A, C) <br/> 8 - 11</td>
<td align="center">(A, B, D) <br/> 9 - 13</td>
<td align="center">(A, B, C) <br/> 10 - 14</td>
</tr>

<tr>
<td align="center">5</td>
<td align="center">NA</td>
<td align="center">(A) <br/> 2 - 6</td>
<td align="center">(A) <br/> 2 - 6</td>
<td align="center">(A, B) <br/> 4 - 9</td>
<td align="center">(A, B) <br/> 4 - 9</td>
<td align="center">(A, E) <br/> 6 - 12</td>
<td align="center">(A, E) <br/> 6 - 12</td>
<td align="center">(A, B, E) <br/> 8 - 15</td>
<td align="center">(A, B, E) <br/> 8 - 15</td>
<td align="center">(A, B, E) <br/> 8 - 15</td>
</tr>
</tbody>
</table>

<p>其中，NA 表示未选取任何物品，单元格上部括号中的为选取物品的编号，单元格下部分别为选取物品的总重量和总价值。</p>

<h3 id="最长公共子序列与最长公共子串">最长公共子序列与最长公共子串</h3>

<p>给定一个序列 <code>$X = \left\{x_1, x_2, \dotsc, x_m\right\}$</code>，另一个序列 <code>$Z = \left\{z_1, z_2, \dotsc, z_k\right\}$</code> 在满足如下条件时称其为 <code>$X$</code> 的一个 <strong>子序例 (Subsequence)</strong>，即存在一个严格递增的 <code>$X$</code> 的下标序列 <code>$\left\{i_1, i_2, \dotsc, i_k\right\}$</code>，对于所有的 <code>$j = 1, 2, \dotsc, k$</code>，满足 <code>$x_{i_j} = z_j$</code>。给定两个序例 <code>$X$</code> 和 <code>$Y$</code>，如果 <code>$Z$</code> 既是 <code>$X$</code> 的子序列，也是 <code>$Y$</code> 的子序列，则称它为 <code>$X$</code> 和 <code>$Y$</code> 的 <strong>公共子序列 (Common Subsequence)</strong>。<strong>最长公共子序列 (Longest Common Subsequence)</strong> 问题为给定两个序列 <code>$X = \left\{x_1, x_2, \dotsc, x_m\right\}$</code> 和 <code>$Y = \left\{y_1, y_2, \dotsc, y_n\right\}$</code>，求 <code>$X$</code> 和 <code>$Y$</code> 最长的公共子序列。</p>

<p>我们可以按如下递归的方式求解最长公共子序列问题：</p>

<ol>
<li>当 <code>$x_i = y_j$</code> 时，求解 <code>$X = \left\{x_1, x_2, \dotsc, x_{i-1}\right\}$</code> 和 <code>$Y = \left\{y_1, y_2, \dotsc, y_{j-1}\right\}$</code> 的最长公共子序列，在其尾部添加 <code>$x_i$</code> 和 <code>$y_j$</code> 即为当前状态下的最长公共子序列。</li>
<li>当 <code>$x_i \neq y_j$</code> 时，我们则需求解 <code>$X = \left\{x_1, x_2, \dotsc, x_{i-1}\right\}$</code> 和 <code>$Y = \left\{y_1, y_2, \dotsc, y_j\right\}$</code> 与 <code>$X = \left\{x_1, x_2, \dotsc, x_i\right\}$</code> 和 <code>$Y = \left\{y_1, y_2, \dotsc, y_{j-1}\right\}$</code> 两种情况下最长的公共子序列作为当前状态下的最长公共子序列。</li>
</ol>

<p>用 <code>$c_{i, j}$</code> 表示<code>$X = \left\{x_1, x_2, \dotsc, x_i\right\}$</code> 和 <code>$Y = \left\{y_1, y_2, \dotsc, y_j\right\}$</code> 情况下的最长公共子序列的长度，则状态转移方程如下：</p>

<p><code>$$
c_{i, w} = 
\begin{cases}
c_{i - 1, j - 1} + i, &amp; x_i = y_j \\
\max \left(c_{i, j - 1}, c_{i - 1, j}\right), &amp; x_i \neq y_j \\
0, &amp; i j = 0
\end{cases}
$$</code></p>

<p>例如：给定序列 <code>$X = \left\{A, B, C, B, D, A, B\right\}$</code> 和序列 <code>$Y = \left\{B, D, C, A, B, A\right\}$</code>，不同状态下最长公共子序列如下表所示 (计算过程详见 <a href="https://github.com/leovan/leovan.me/tree/master/scripts/cn/2018-11-18-computational-complexity-and-dynamic-programming/longest-common-subsequence-dp.py" rel="noreferrer" target="_blank">这里</a>)：</p>

<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"><code>$j$</code></th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center"><code>$i$</code></td>
<td align="center"></td>
<td align="center"><code>$y_j$</code></td>
<td align="center"><strong>B</strong></td>
<td align="center">D</td>
<td align="center"><strong>C</strong></td>
<td align="center">A</td>
<td align="center"><strong>B</strong></td>
<td align="center"><strong>A</strong></td>
</tr>

<tr>
<td align="center">0</td>
<td align="center"><code>$x_i$</code></td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>

<tr>
<td align="center">1</td>
<td align="center">A</td>
<td align="center"><strong>0</strong></td>
<td align="center">0 (↑)</td>
<td align="center">0 (↑)</td>
<td align="center">0 (↑)</td>
<td align="center">1 (↖)</td>
<td align="center">1 (←)</td>
<td align="center">1 (↖)</td>
</tr>

<tr>
<td align="center">2</td>
<td align="center"><strong>B</strong></td>
<td align="center">0</td>
<td align="center"><strong>1 (↖)</strong></td>
<td align="center"><strong>1 (←)</strong></td>
<td align="center">1 (←)</td>
<td align="center">1 (↑)</td>
<td align="center">2 (↖)</td>
<td align="center">2 (←)</td>
</tr>

<tr>
<td align="center">3</td>
<td align="center"><strong>C</strong></td>
<td align="center">0</td>
<td align="center">1 (↑)</td>
<td align="center">1 (↑)</td>
<td align="center"><strong>2 (↖)</strong></td>
<td align="center"><strong>2 (←)</strong></td>
<td align="center">2 (↑)</td>
<td align="center">2 (↑)</td>
</tr>

<tr>
<td align="center">4</td>
<td align="center"><strong>B</strong></td>
<td align="center">0</td>
<td align="center">1 (↖)</td>
<td align="center">1 (↑)</td>
<td align="center">2 (↑)</td>
<td align="center">2 (↑)</td>
<td align="center"><strong>3 (↖)</strong></td>
<td align="center">3 (←)</td>
</tr>

<tr>
<td align="center">5</td>
<td align="center">D</td>
<td align="center">0</td>
<td align="center">1 (↑)</td>
<td align="center">2 (↖)</td>
<td align="center">2 (↑)</td>
<td align="center">2 (↑)</td>
<td align="center"><strong>3 (↑)</strong></td>
<td align="center">3 (↑)</td>
</tr>

<tr>
<td align="center">6</td>
<td align="center"><strong>A</strong></td>
<td align="center">0</td>
<td align="center">1 (↑)</td>
<td align="center">2 (↑)</td>
<td align="center">2 (↑)</td>
<td align="center">3 (↖)</td>
<td align="center">3 (↑)</td>
<td align="center"><strong>4 (↖)</strong></td>
</tr>

<tr>
<td align="center">7</td>
<td align="center">B</td>
<td align="center">0</td>
<td align="center">1 (↖)</td>
<td align="center">2 (↑)</td>
<td align="center">2 (↑)</td>
<td align="center">3 (↑)</td>
<td align="center">4 (↖)</td>
<td align="center"><strong>4 (↑)</strong></td>
</tr>
</tbody>
</table>

<p>其中，每个单元格前面的数字为最长公共子序列的长度，后面的符号为还原最长公共子序列使用的备忘录符号。</p>

<p><strong>最长公共子串 (Longest Common Substring)</strong> 同最长公共子序列问题略有不同，子序列不要求字符是连续的，而子串要求字符必须是连续的。例如：给定序列 <code>$X = \left\{A, B, C, B, D, A, B\right\}$</code> 和序列 <code>$Y = \left\{B, D, C, A, B, A\right\}$</code>，最长公共子序列为 <code>$\left\{B, C, B, A\right\}$</code>，而最长公共子串为 <code>$\left\{A, B\right\}$</code> 或 <code>$\left\{B, D\right\}$</code>。用 <code>$c_{i, j}$</code> 表示<code>$X = \left\{x_1, x_2, \dotsc, x_i\right\}$</code> 和 <code>$Y = \left\{y_1, y_2, \dotsc, y_j\right\}$</code> 情况下的最长公共子串的长度，则状态转移方程如下：</p>

<p><code>$$
c_{i, w} = 
\begin{cases}
c_{i - 1, j - 1} + i, &amp; x_i = y_j \\
0, &amp; x_i \neq y_j \\
0, &amp; i j = 0
\end{cases}
$$</code></p>

<p>利用动态规划可以在 <code>$\Theta \left(nm\right)$</code> 的时间复杂度内求解，利用广义后缀树 <sup class="footnote-ref" id="fnref:wikipedia-suffix-tree"><a href="#fn:wikipedia-suffix-tree">3</a></sup> 可以进一步降低问题求解的时间复杂度 <sup class="footnote-ref" id="fnref:wikipedia-longest-common-substring-problem"><a href="#fn:wikipedia-longest-common-substring-problem">4</a></sup>。</p>

<h3 id="floyd-warshall-算法">Floyd-Warshall 算法</h3>

<p><strong>Floyd-Warshall 算法</strong> 是一种求解任意两点之间 <strong>最短路</strong> 的算法，相比 <strong>Dijkstra 算法</strong> <sup class="footnote-ref" id="fnref:wikipedia-dijkstra-algorithm"><a href="#fn:wikipedia-dijkstra-algorithm">5</a></sup>，Floyd-Warshall 算法可以处理有向图或负权图 (但不可以存在负权回路) 的情况 <sup class="footnote-ref" id="fnref:wikipedia-floyd-warshall-algorithm"><a href="#fn:wikipedia-floyd-warshall-algorithm">6</a></sup>。</p>

<p>用 <code>$d_{i, j}^{\left(k\right)}$</code> 表示从 <code>$i$</code> 到 <code>$j$</code> 路径上最大节点的标号为 <code>$k$</code> 的最短路径的长度。有：</p>

<ol>
<li><code>$d_{i, j}^{\left(k\right)} = d_{i, k}^{\left(k-1\right)} + d_{k, j}^{\left(k-1\right)}$</code>，若最短路径经过点 <code>$k$</code>。</li>
<li><code>$d_{i, j}^{\left(k\right)} = d_{i, j}^{\left(k-1\right)}$</code>，若最短路径不经过点 <code>$k$</code>。</li>
</ol>

<p>则状态转移方程如下：</p>

<p><code>$$
d_{i, j}^{\left(k\right)} = 
\begin{cases}
w_{i, j}, &amp; k = 0 \\
\min \left(d_{i, j}^{\left(k-1\right)}, d_{i, k}^{\left(k-1\right)} + d_{k, j}^{\left(k-1\right)}\right), &amp; k \leq 1
\end{cases}
$$</code></p>

<p>以下图所示的最短路问题为例：</p>

<p><img src="/images/cn/2018-11-18-computational-complexity-and-dynamic-programming/shortest-path.png" alt="" /></p>

<p>Floyd-Warshall 算法的求解伪代码如下所示：</p>



<link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/pseudocode@latest/build/pseudocode.min.css">


<div><pre class="pseudocode">
\begin{algorithm}
\caption{Floyd-Warshall 算法}
\begin{algorithmic}
\REQUIRE \\
    边集合 $w$ \\
    顶点数量 $c$
\ENSURE \\
    距离矩阵 $d$ \\
    备忘录矩阵 $m$
\FUNCTION{Floyd-Warshall}{$w, c$}
\FOR{$i$ = $1$ to $c$}
    \FOR{$j$ = $1$ to $c$}
        \STATE $d_{i, j} \gets \infty$
    \ENDFOR
\ENDFOR
\FOR{$i$ = $1$ to $c$}
    \STATE $d_{i, i} \gets 0$
\ENDFOR
\FORALL{$w_{i, j}$}
    \STATE $d_{i, j} \gets w_{i, j}$
\ENDFOR
\FOR{$k$ = $1$ to $c$}
    \FOR{$i$ = $1$ to $c$}
        \FOR{$j$ = $1$ to $c$}
            \IF{$d_{i, j} > d_{i, k} + d_{k, j}$}
                \STATE $d_{i, j} \gets d_{i, k} + d_{k, j}$
                \STATE $m_{i, j} \gets k$
            \ENDIF
        \ENDFOR
    \ENDFOR
\ENDFOR
\ENDFUNCTION
\end{algorithmic}
\end{algorithm}
</pre></div>


<p>通过备忘录矩阵 <code>$m$</code>，恢复从点 <code>$i$</code> 到点 <code>$j$</code> 的过程如下所示：</p>



<div><pre class="pseudocode">
\begin{algorithm}
\caption{Floyd-Warshall-Path 算法}
\begin{algorithmic}
\REQUIRE \\
    备忘录矩阵 $m$ \\
    起点 $i$ \\
    终点 $j$ \\
    路径 $p$
\FUNCTION{Floyd-Warshall-Path}{$m, i, j, p$}
\IF{$i == j$}
    \RETURN
\ENDIF
\IF{$m_{i, j} == 0$}
    \STATE $p \gets p \cup j$
\ELSE
    \STATE Floyd-Warshall-Path($m, i, m_{i, j}, p$)
    \STATE Floyd-Warshall-Path($m, m_{i, j}, j, p$)
\ENDIF
\ENDFUNCTION
\end{algorithmic}
\end{algorithm}
</pre></div>


<blockquote>
<p>文章部分内容参考了 Thomas H. Cormen 等人的《算法导论》</p>
</blockquote>
<div class="footnotes">

<hr />

<ol>
<li id="fn:wikipedia-computational-complexity-theory"><a href="https://zh.wikipedia.org/zh/计算复杂性理论" rel="noreferrer" target="_blank">https://zh.wikipedia.org/zh/计算复杂性理论</a>
 <a class="footnote-return" href="#fnref:wikipedia-computational-complexity-theory">↩</a></li>
<li id="fn:wikipedia-dynamic-programming"><a href="https://zh.wikipedia.org/zh/动态规划" rel="noreferrer" target="_blank">https://zh.wikipedia.org/zh/动态规划</a>
 <a class="footnote-return" href="#fnref:wikipedia-dynamic-programming">↩</a></li>
<li id="fn:wikipedia-suffix-tree"><a href="https://zh.wikipedia.org/zh/后缀树" rel="noreferrer" target="_blank">https://zh.wikipedia.org/zh/后缀树</a>
 <a class="footnote-return" href="#fnref:wikipedia-suffix-tree">↩</a></li>
<li id="fn:wikipedia-longest-common-substring-problem"><a href="https://zh.wikipedia.org/zh/最长公共子串" rel="noreferrer" target="_blank">https://zh.wikipedia.org/zh/最长公共子串</a>
 <a class="footnote-return" href="#fnref:wikipedia-longest-common-substring-problem">↩</a></li>
<li id="fn:wikipedia-dijkstra-algorithm"><a href="https://zh.wikipedia.org/zh/戴克斯特拉算法" rel="noreferrer" target="_blank">https://zh.wikipedia.org/zh/戴克斯特拉算法</a>
 <a class="footnote-return" href="#fnref:wikipedia-dijkstra-algorithm">↩</a></li>
<li id="fn:wikipedia-floyd-warshall-algorithm"><a href="https://zh.wikipedia.org/zh/Floyd-Warshall算法" rel="noreferrer" target="_blank">https://zh.wikipedia.org/zh/Floyd-Warshall算法</a>
 <a class="footnote-return" href="#fnref:wikipedia-floyd-warshall-algorithm">↩</a></li>
</ol>
</div>



<link rel="stylesheet" href="/css/donate.css" />


<div class="donate">
  <div class="donate-header"></div>
  <div class="donate-slug" id="donate-slug">computational-complexity-and-dynamic-programming</div>
  <button class="donate-button">赞 赏</button>
  <div class="donate-footer">「真诚赞赏，手留余香」</div>
</div>
<div class="donate-modal-wrapper">
  <div class="donate-modal">
    <div class="donate-box">
      <div class="donate-box-content">
        <div class="donate-box-content-inner">
          <div class="donate-box-header">「真诚赞赏，手留余香」</div>
          <div class="donate-box-body">
            <div class="donate-box-money">
              <button class="donate-box-money-button donate-box-money-button-unchecked" id="donate-box-money-button-2" data-v="2" data-unchecked="￥ 2" data-checked="2 元">￥ 2</button>
              <button class="donate-box-money-button donate-box-money-button-unchecked" id="donate-box-money-button-5" data-v="5" data-unchecked="￥ 5" data-checked="5 元">￥ 5</button>
              <button class="donate-box-money-button donate-box-money-button-unchecked" id="donate-box-money-button-10" data-v="10" data-unchecked="￥ 10" data-checked="10 元">￥ 10</button>
              <button class="donate-box-money-button donate-box-money-button-unchecked" id="donate-box-money-button-50" data-v="50" data-unchecked="￥ 50" data-checked="50 元">￥ 50</button>
              <button class="donate-box-money-button donate-box-money-button-unchecked" id="donate-box-money-button-100" data-v="100" data-unchecked="￥ 100" data-checked="100 元">￥ 100</button>
              <button class="donate-box-money-button donate-box-money-button-unchecked" id="donate-box-money-button-custom" data-v="custom" data-unchecked="任意金额" data-checked="任意金额">任意金额</button>
            </div>
            <div class="donate-box-pay">
              <img class="donate-box-pay-qrcode" id="donate-box-pay-qrcode" src=""/>
            </div>
          </div>
          <div class="donate-box-footer">
            <div class="donate-box-pay-method donate-box-pay-method-checked" data-v="wechat-pay">
              <img class="donate-box-pay-method-image" id="donate-box-pay-method-image-wechat-pay" src=""/>
            </div>
            <div class="donate-box-pay-method" data-v="alipay">
              <img class="donate-box-pay-method-image"  id="donate-box-pay-method-image-alipay" src=""/>
            </div>
          </div>
        </div>
      </div>
    </div>
    <button type="button" class="donate-box-close-button">
      <svg class="donate-box-close-button-icon" fill="#fff" viewBox="0 0 24 24" width="24" height="24"><path d="M13.486 12l5.208-5.207a1.048 1.048 0 0 0-.006-1.483 1.046 1.046 0 0 0-1.482-.005L12 10.514 6.793 5.305a1.048 1.048 0 0 0-1.483.005 1.046 1.046 0 0 0-.005 1.483L10.514 12l-5.208 5.207a1.048 1.048 0 0 0 .006 1.483 1.046 1.046 0 0 0 1.482.005L12 13.486l5.207 5.208a1.048 1.048 0 0 0 1.483-.006 1.046 1.046 0 0 0 .005-1.482L13.486 12z" fill-rule="evenodd"></path></svg>
    </button>
  </div>
</div>

<script type="text/javascript" src="/js/donate.js"></script>
</script>


  <footer>
  
<nav class="post-nav">
  <span class="nav-prev">&larr; <a href="/cn/2018/10/serving-models-with-flask-and-gae/">利用 Flask 和 Google App Engine 部署模型服务</a></span>
  <span class="nav-next"><a href="/cn/2018/12/ensemble-learning/">集成学习算法 (Ensemble Learning)</a> &rarr;</span>
</nav>
<script type="text/javascript">
document.addEventListener('keyup', function(e) {
  if (e.target.nodeName.toUpperCase() != 'BODY') return;
  var url = false;
  if (e.which == 37) {  
    
    url = '\/cn\/2018\/10\/serving-models-with-flask-and-gae\/';
    
  } else if (e.which == 39) {  
    
    url = '\/cn\/2018\/12\/ensemble-learning\/';
    
  }
  if (url) window.location = url;
});
</script>




<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-2608165017777396"
     data-ad-slot="1261604535"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>





<section class="comments">
  <div id="disqus_thread"></div>
  <script>
  var disqus_config = function () {
  
    this.page.url = "https:\/\/zeqiang.fun" + location.pathname;
  
  };
  (function() {
    var inIFrame = function() {
      var iframe = true;
      try { iframe = window.self !== window.top; } catch (e) {}
      return iframe;
    };
    if (inIFrame()) return;
    var disqus_js = '//Zeqiang.disqus.com/embed.js';
    var d = document, s = d.createElement('script');
    s.src = disqus_js; s.async = true;
    s.setAttribute('data-timestamp', +new Date());
    var t = d.getElementById('disqus_thread');
    var b = false, l = function(scroll) {
      if (b) return;
      (d.head || d.body).appendChild(s); b = true;
      if (scroll) t.scrollIntoView();
    }
    s.onerror = function(e) {
      if (sessionStorage.getItem('failure-note')) return;
      t.innerText = 'Sorry, but you cannot make comments because Disqus failed to load for some reason. It is known to be blocked in China. If you are sure it is not blocked in your region, please refresh the page. 中国大陆地区读者需要翻墙才能发表评论。';
      sessionStorage.setItem('failure-note', true);
    };
    
    if (location.hash.match(/^#comment-[0-9]+$/)) return l(true);
    var c = function() {
      if (b) return;
      var rect = t.getBoundingClientRect();
      if (rect.top < window.innerHeight && rect.bottom >= 0) l();
    };
    window.addEventListener('load', c);
    d.addEventListener('scroll', c);
  })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</section>





<script src="//cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/prism.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/autoloader/prism-autoloader.min.js"></script>

<script src="//cdnjs.cloudflare.com/ajax/libs/prism/1.25.0/plugins/show-language/prism-show-language.min.js"></script>

<script>
    (function() {
        if (!self.Prism) {
            return;
        }

        Prism.languages.dos = Prism.languages.powershell;
        Prism.languages.gremlin = Prism.languages.groovy;

        var Languages = {
            'r': 'R', 'python': 'Python', 'xml': 'XML', 'html': 'HTML',
            'yaml': 'YAML', 'latex': 'LaTeX', 'tex': 'TeX',
            'powershell': 'PowerShell', 'javascript': 'JavaScript',
            'dos': 'DOS', 'qml': 'QML', 'json': 'JSON', 'bash': 'Bash',
            'text': 'Text', 'txt': 'Text', 'sparql': 'SPARQL',
            'gremlin': 'Gremlin', 'cypher': 'Cypher', 'ngql': 'nGQL',
            'shell': 'Shell', 'sql': 'SQL', 'apacheconf': 'Apache Configuration'
        };

        Prism.hooks.add('before-highlight', function(env) {
        	var language = Languages[env.language] || env.language;
        	env.element.setAttribute('data-language', language);
        });
    })();
</script>




<script async src="/js/fix-toc.js"></script>
<script async src="/js/center-img.js"></script>
<script async src="/js/right-quote.js"></script>
<script async src="/js/fix-footnote.js"></script>
<script async src="/js/external-link.js"></script>
<script async src="/js/alt-title.js"></script>
<script src="/js/no-highlight.js"></script>
<script src="/js/math-code.js"></script>


<script>
window.MathJax = {
  loader: {
    load: ['[tex]/boldsymbol']
  },
  tex: {
    tags: "all",
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$']],
    processEscapes: true,
    processEnvironments: true,
    packages: {
      '[+]': ['boldsymbol']
    }
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.0/es5/tex-chtml.js" crossorigin></script>


<script src="//cdn.jsdelivr.net/npm/pseudocode@latest/build/pseudocode.min.js"></script>
<script type="text/javascript">
$(document).ready(function() {
    var captionCount = 0;
    $(".pseudocode").each(function() {
        var pseudocode_options = {
            indentSize: '1.2em',
            commentDelimiter: '\/\/',
            lineNumber:  true ,
            lineNumberPunc: ':',
            noEnd:  false 
        };
        pseudocode_options.captionCount = captionCount;
        captionCount += 1;
        var codeEl = $(this).get(0);
        pseudocode.render(codeEl.textContent, codeEl.parentElement, pseudocode_options);
    });
});
</script>






<script async src="/js/load-typekit.js"></script>

<script src="//cdnjs.cloudflare.com/ajax/libs/lazysizes/5.3.2/lazysizes.min.js"></script>

<script src="//cdn.jsdelivr.net/npm/vanilla-back-to-top@latest/dist/vanilla-back-to-top.min.js"></script>
<script>
addBackToTop({
  diameter: 48
})
</script>



  <hr>
  <div class="copyright no-border-bottom">
    <div class="copyright-author-year">
      <span>&copy; 2017-2021 Leo Van</span>
    </div>
    <div class="copyright-links">
      <a href="https://github.com/leovan" rel="noreferrer" target="_blank">Github</a>
      <span> · </span>
      <a href="https://orcid.org/0000-0002-9556-7821" rel="noreferrer" target="_blank">ORCID</a>
      <span> · </span>
      <span>I am Mr. Black.</span>
    </div>
  </div>
  </footer>
  </article>
  </body>
</html>


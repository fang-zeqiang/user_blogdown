<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">

        <title>预训练自然语言模型 (Pre-trained Models for NLP) - Zeqiang Fang | 方泽强</title>

    <meta name="referrer" content="no-referrer">
    
    <meta property="og:title" content="预训练自然语言模型 (Pre-trained Models for NLP) - Zeqiang Fang | 方泽强">
    <meta name="description" property="og:description" content="本文为 Pre-trained Models for Natural Language Processing: A Survey 和相关模型的读书笔记 1。 在当下的 NLP 研究领域，随着计算机算力的不断增强，越来越多的通用语言表征的预训练模型（Pre-tr">
    <meta property="og:type" content="article">
    <meta property="og:site_name" content="Zeqiang Fang | 方泽强">
    <meta property="og:url" content="http://zeqiang.fun/user_blogdown/cn/2020/03/pre-trained-model-for-nlp/">

    
    
    
    
    <meta name="author" property="article:author" content="范叶亮">
    
    
    
    <meta name="date" property="article:published_time" content="2020-03-28" scheme="YYYY-MM-DD">
    
    
    <meta name="date" property="article:modified_time" content="2020-03-28" scheme="YYYY-MM-DD">
    

    
    <meta name="keywords" property="article:tag" content ="预训练,Pre-trained,迁移学习,Transfer Learning,上下文感知,Contextual,Transformer,机器翻译,Machine Translation,语言模型,Language Modeling,LM,遮罩语言模型,Masked Language Modeling,MLM,排列语言模型,Permuted Language Modeling,PLM,去噪自编码,Denoising Autoencoder,DAE,对比学习,Contrastive Learning,CTL,CBOW,Skip-gram,Word2Vec,GloVe,CoVe,ELMo,GPT,BERT,UniLM,Transformer-XL,XLNet,MASS,RoBERTa,BART,T5,ERNIE">
    
    
    <meta name="theme-color" content="#0d0d0d">
    
    <link rel="icon" type="image/png" sizes="16x16" href="/images/web/favicon-16x16.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/images/web/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="48x48" href="/images/web/favicon-48x48.png">
    <link rel="icon" type="image/png" sizes="62x62" href="/images/web/favicon-62x62.png">
    <link rel="icon" type="image/png" sizes="192x192" href="/images/web/favicon-192x192.png">
    <link rel="apple-touch-icon" size="192x192" href="/images/web/icon-192x192.png">
    <link rel="manifest" href="/manifest.json">
        
    

    

    <script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "http://zeqiang.fun/user_blogdown/cn"
        },
        "name": "预训练自然语言模型 (Pre-trained Models for NLP)",
        "headline": "预训练自然语言模型 (Pre-trained Models for NLP)",
        "description" : "本文为 Pre-trained Models for Natural Language Processing: A Survey 和相关模型的读书笔记 1。 在当下的 NLP 研究领域，随着计算机算力的不断增强，越来越多的通用语言表征的预训练模型（Pre-tr",
        "genre": [
            "深度学习", "表示学习", "自然语言处理"
        ],
        "datePublished": "2020-03-28",
        "dateModified": "2020-03-28",
        "wordCount": "13467",
        "keywords": [
            "预训练", "Pre-trained", "迁移学习", "Transfer Learning", "上下文感知", "Contextual", "Transformer", "机器翻译", "Machine Translation", "语言模型", "Language Modeling", "LM", "遮罩语言模型", "Masked Language Modeling", "MLM", "排列语言模型", "Permuted Language Modeling", "PLM", "去噪自编码", "Denoising Autoencoder", "DAE", "对比学习", "Contrastive Learning", "CTL", "CBOW", "Skip-gram", "Word2Vec", "GloVe", "CoVe", "ELMo", "GPT", "BERT", "UniLM", "Transformer-XL", "XLNet", "MASS", "RoBERTa", "BART", "T5", "ERNIE"
        ],
        "image": [
            "http://zeqiang.fun/images/cn/2020-03-28-pre-trained-model-for-nlp/ptms.png"
        ],
        "author": {
            "@type": "Person",
            "name": "范叶亮"
        },
        "publisher": {
            "@type": "Organization",
            "name": "范叶亮",
            "logo": {
                "@type": "ImageObject",
                "url": "http://zeqiang.fun/images/web/publisher-logo.png"
            }
        },
        "url": "http://zeqiang.fun/user_blogdown/cn/2020/03/pre-trained-model-for-nlp/"
    }
    </script>
    

    <script src='//cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js'></script>
<script src='//cdnjs.cloudflare.com/ajax/libs/js-cookie/2.2.1/js.cookie.min.js'></script>

<link rel="stylesheet" type="text/css" href="//cdnjs.cloudflare.com/ajax/libs/MaterialDesign-Webfont/6.5.95/css/materialdesignicons.min.css">





<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<link rel="stylesheet" type="text/css" href="/user_blogdown/css/fonts.css" />
<link rel="stylesheet" type="text/css" href="/user_blogdown/css/style.css">
<link rel="stylesheet" type="text/css" href="/user_blogdown/css/light.css">
<link rel="stylesheet" type="text/css" href="/user_blogdown/css/dark.css" id="dark-mode-style" disabled="disabled">
<link rel="stylesheet" type="text/css" href="/user_blogdown/css/icons.css">
<link rel="stylesheet" type="text/css" href="/user_blogdown/css/print.css">

  </head>

  
  <body class="user_blogdown">
    <header class="masthead">
      

<div class="logo"></div>
<p class="slogan">优雅永不过时</p>
      <nav class="menu">
  <ul>
  
  
  
    
  
  
    <li><a href="/user_blogdown/">首页</a></li>
  
    <li><a href="/user_blogdown/cn/">博客</a></li>
  
    <li><a href="/user_blogdown/cn/about/">关于</a></li>
  
    <li class="menu-separator"><span>&nbsp;</span></li>
  
    <li><a href="/user_blogdown/">Home</a></li>
  
    <li><a href="/user_blogdown/en/">Blog</a></li>
  
    <li><a href="/user_blogdown/en/about/">About</a></li>
  
  


<li class="menu-separator"><span>&nbsp;</span></li>

<li><a href="/cn/index.xml" target="_blank" type="application/rss+xml" title="RSS feed">订阅</a></li>

<li><a href="https://github.com/fang-zeqiang/fang-zeqiang.github.io/blob/master/LICENSE" target="_blank" title="Attribution-NonCommercial-ShareAlike 4.0 International">版权</a></li>


  <li class="light-dark-mode no-border-bottom"><a id="light-dark-mode-action"><span id="light-dark-mode-icon" class="mdi mdi-weather-night"></span></a></li>
  </ul>
</nav>

      <script src="/js/toggle-theme.js"></script>
    </header>

    <article class="main">
      <header class="title">
      
<h1>预训练自然语言模型 (Pre-trained Models for NLP)</h1>







<h3>范叶亮 / 
2020-03-28</h3>



<h3 class="post-meta">


<strong>分类: </strong>
<a href="/user_blogdown/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0">深度学习</a>, <a href="/user_blogdown/categories/%E8%A1%A8%E7%A4%BA%E5%AD%A6%E4%B9%A0">表示学习</a>, <a href="/user_blogdown/categories/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86">自然语言处理</a>




/




<strong>标签: </strong>
<span>预训练</span>, <span>Pre-trained</span>, <span>迁移学习</span>, <span>Transfer Learning</span>, <span>上下文感知</span>, <span>Contextual</span>, <span>Transformer</span>, <span>机器翻译</span>, <span>Machine Translation</span>, <span>语言模型</span>, <span>Language Modeling</span>, <span>LM</span>, <span>遮罩语言模型</span>, <span>Masked Language Modeling</span>, <span>MLM</span>, <span>排列语言模型</span>, <span>Permuted Language Modeling</span>, <span>PLM</span>, <span>去噪自编码</span>, <span>Denoising Autoencoder</span>, <span>DAE</span>, <span>对比学习</span>, <span>Contrastive Learning</span>, <span>CTL</span>, <span>CBOW</span>, <span>Skip-gram</span>, <span>Word2Vec</span>, <span>GloVe</span>, <span>CoVe</span>, <span>ELMo</span>, <span>GPT</span>, <span>BERT</span>, <span>UniLM</span>, <span>Transformer-XL</span>, <span>XLNet</span>, <span>MASS</span>, <span>RoBERTa</span>, <span>BART</span>, <span>T5</span>, <span>ERNIE</span>




/


<strong>字数: </strong>
13467
</h3>



<hr>


      </header>



<div class="toc-depth-2" ><nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#预训练原理">预训练原理</a>
<ul>
<li><a href="#语言表示学习">语言表示学习</a></li>
<li><a href="#神经上下文编码器">神经上下文编码器</a></li>
<li><a href="#为什么预训练">为什么预训练</a></li>
<li><a href="#预训练任务">预训练任务</a>
<ul>
<li><a href="#语言模型-language-modeling-lm">语言模型（Language Modeling，LM）</a></li>
<li><a href="#遮罩语言模型-masked-language-modeling-mlm">遮罩语言模型（Masked Language Modeling，MLM）</a>
<ul>
<li><a href="#sequence-to-sequence-mlm-seq2seq-mlm">Sequence-to-Sequence MLM (Seq2Seq MLM)</a></li>
<li><a href="#enhanced-masked-language-modeling-e-mlm">Enhanced Masked Language Modeling (E-MLM)</a></li>
</ul></li>
<li><a href="#排列语言模型-permuted-language-modeling-plm">排列语言模型（Permuted Language Modeling，PLM）</a></li>
<li><a href="#去噪自编码-denoising-autoencoder-dae">去噪自编码（Denoising Autoencoder，DAE）</a></li>
<li><a href="#对比学习-contrastive-learning-ctl">对比学习（Contrastive Learning，CTL）</a></li>
</ul></li>
<li><a href="#应用于下游任务">应用于下游任务</a>
<ul>
<li><a href="#如何迁移">如何迁移</a>
<ul>
<li><a href="#选择合适的预训练任务-模型架构和语料">选择合适的预训练任务，模型架构和语料</a></li>
<li><a href="#选择合适的网络层">选择合适的网络层</a></li>
<li><a href="#是否微调">是否微调</a></li>
</ul></li>
<li><a href="#微调策略">微调策略</a>
<ul>
<li><a href="#两步骤微调">两步骤微调</a></li>
<li><a href="#多任务微调">多任务微调</a></li>
<li><a href="#利用额外模块进行微调">利用额外模块进行微调</a></li>
</ul></li>
</ul></li>
<li><a href="#开放资源">开放资源</a>
<ul>
<li><a href="#ptms-开源实现">PTMs 开源实现：</a></li>
<li><a href="#论文列表和-ptms-相关资源">论文列表和 PTMs 相关资源：</a></li>
</ul></li>
</ul></li>
<li><a href="#预训练模型">预训练模型</a>
<ul>
<li><a href="#cove-2017-mccann2017learned">CoVe (2017) <sup class="footnote-ref" id="fnref:mccann2017learned"><a href="#fn:mccann2017learned">4</a></sup></a></li>
<li><a href="#elmo-2018-peters2018deep">ELMo (2018) <sup class="footnote-ref" id="fnref:peters2018deep"><a href="#fn:peters2018deep">5</a></sup></a></li>
<li><a href="#gpt-2018-radford2018improving">GPT (2018) <sup class="footnote-ref" id="fnref:radford2018improving"><a href="#fn:radford2018improving">6</a></sup></a></li>
<li><a href="#bert-2018-devlin2018bert">BERT (2018) <sup class="footnote-ref" id="fnref:devlin2018bert"><a href="#fn:devlin2018bert">7</a></sup></a></li>
<li><a href="#unilm-2019-dong2019unified">UniLM (2019) <sup class="footnote-ref" id="fnref:dong2019unified"><a href="#fn:dong2019unified">25</a></sup></a></li>
<li><a href="#transformer-xl-2019-dai2019transformer">Transformer-XL (2019) <sup class="footnote-ref" id="fnref:dai2019transformer"><a href="#fn:dai2019transformer">26</a></sup></a></li>
<li><a href="#xlnet-2019-yang2019xlnet">XLNet (2019) <sup class="footnote-ref" id="fnref:yang2019xlnet"><a href="#fn:yang2019xlnet">19</a></sup></a></li>
<li><a href="#mass-2019-song2019mass">MASS (2019) <sup class="footnote-ref" id="fnref:song2019mass"><a href="#fn:song2019mass">16</a></sup></a></li>
<li><a href="#roberta-2019-liu2019roberta">RoBERTa (2019) <sup class="footnote-ref" id="fnref:liu2019roberta"><a href="#fn:liu2019roberta">18</a></sup></a></li>
<li><a href="#bart-2019-lewis2019bart">BART (2019) <sup class="footnote-ref" id="fnref:lewis2019bart"><a href="#fn:lewis2019bart">20</a></sup></a></li>
<li><a href="#t5-2019-raffel2019exploring">T5 (2019) <sup class="footnote-ref" id="fnref:raffel2019exploring"><a href="#fn:raffel2019exploring">17</a></sup></a></li>
<li><a href="#ernie-baidu-2019-sun2019ernie-sun2019ernie2">ERNIE (Baidu, 2019) <sup class="footnote-ref" id="fnref:sun2019ernie"><a href="#fn:sun2019ernie">29</a></sup> <sup class="footnote-ref" id="fnref:sun2019ernie2"><a href="#fn:sun2019ernie2">30</a></sup></a></li>
<li><a href="#state-of-art">State-of-Art</a></li>
</ul></li>
</ul></li>
</ul>
</nav></div> 




<blockquote>
<p>本文为 Pre-trained Models for Natural Language Processing: A Survey 和相关模型的读书笔记 <sup class="footnote-ref" id="fnref:qiu2020pre"><a href="#fn:qiu2020pre">1</a></sup>。</p>
</blockquote>

<p>在当下的 NLP 研究领域，随着计算机算力的不断增强，越来越多的通用语言表征的预训练模型（Pre-trained Models，PTMs）逐渐涌现出来。这对下游的 NLP 任务非常有帮助，可以避免大量从零开始训练新的模型。PTM 大致可以分为两代：</p>

<ul>
<li>第一代 PTM 旨在学习词嵌入。由于下游任务不在需要这些模型，因此为了计算效率，这些模型往往采用浅层模型，例如 Skip-Gram <sup class="footnote-ref" id="fnref:mikolov2013distributed"><a href="#fn:mikolov2013distributed">2</a></sup>，GloVe <sup class="footnote-ref" id="fnref:pennington2014glove"><a href="#fn:pennington2014glove">3</a></sup> 等。尽管这些模型可以捕获词的语义，但由于未基于上下文环境，因此不能够捕捉到更深层次的概念，例如：句法结构，语义角色，指代等等。</li>
<li>第二代 PTM 专注于学习基于上下文的词嵌入，例如 CoVe <sup class="footnote-ref" id="fnref:mccann2017learned"><a href="#fn:mccann2017learned">4</a></sup>，ELMo <sup class="footnote-ref" id="fnref:peters2018deep"><a href="#fn:peters2018deep">5</a></sup>，OpenAI GPT <sup class="footnote-ref" id="fnref:radford2018improving"><a href="#fn:radford2018improving">6</a></sup> 和 BERT <sup class="footnote-ref" id="fnref:devlin2018bert"><a href="#fn:devlin2018bert">7</a></sup> 等。这些学习到的编码器在下游任务中仍会用于词在上下文中的语义表示。</li>
</ul>

<h2 id="预训练原理">预训练原理</h2>

<h3 id="语言表示学习">语言表示学习</h3>

<p>分布式表示的核心思想为用一个低维的实值向量表示一段文本，向量单独每个维度不具有任何实质含义，但整个向量表示了一个具体的概念。下图展示了一个 NLP 任务的一般神经网络架构：</p>

<figure>
  <img data-src="/images/cn/2020-03-28-pre-trained-model-for-nlp/generic-neural-architecture-for-nlp.png" class="lazyload"/>
  <figcaption><p class="figcaption">NLP 任务的一般神经网络架构</p></figcaption>
</figure>

<p>词嵌入包含两种类型：<strong>上下文无关的词嵌入</strong>和<strong>基于上下文的词嵌入</strong>。两者的不同点在于一个词的嵌入是够会随着上下文的不同而随之改变。</p>

<ul>
<li>上下文无关的词嵌入</li>
</ul>

<p>为了表征语义，我们需要将离散的语言符号映射到一个分布式嵌入空间中。对于词典 <code>$\mathcal{V}$</code> 中的一个词 <code>$x$</code>，我们将其映射为查询表 <code>$\mathbf{E} \in \mathbb{R}^{D_e \times \|\mathcal{V}\|}$</code> 中的一个向量 <code>$\mathbf{e}_x \in \mathbb{R}^{D_e}$</code>，其中 <code>$D_e$</code> 为嵌入的维度。</p>

<p>这种类型的嵌入主要有两个缺陷：一是嵌入是静态的，词在不同的上下文中的嵌入表示是相同的，因此无法处理一词多义；二是未登录词（out-of-vocabulary，OOV）问题，通常可以采用字符级嵌入表示解决该问题。更多上下文无关的词嵌入模型，请参见之前的博客 <a href="/cn/2018/10/word-embeddings/">词向量</a>。</p>

<ul>
<li>基于上下文的词嵌入</li>
</ul>

<p>为了解决上述问题，我们需要区分在不同上下文下词的含义。给定一段文本 <code>$x_1, x_2, \dotsc, x_T$</code> 其中每段标记 <code>$x_t \in \mathcal{V}$</code> 为一个词或子词，<code>$x_t$</code> 基于上下文的表示依赖于整段文本。</p>

<p><code>$$
\left[\mathbf{h}_1, \mathbf{h}_2, \dotsc, \mathbf{h}_T\right] = f_{\text{enc}} \left(x_1, x_2, \dotsc, x_T\right)
$$</code></p>

<p>其中，<code>$f_{\text{enc}} \left(\cdot\right)$</code> 为神经编码器，<code>$\mathbf{h}_t$</code> 为标记 <code>$x_t$</code> 的<strong>基于上下文的嵌入</strong>或<strong>动态嵌入</strong>。</p>

<h3 id="神经上下文编码器">神经上下文编码器</h3>

<p>神经上下文编码器大致可以分为 3 类：</p>

<ol>
<li><strong>基于卷积的模型</strong>：基于卷积的模型通过卷积操作从一个词的邻居中聚合局部信息来捕获这个词的含义 <sup class="footnote-ref" id="fnref:kim2014convolutional"><a href="#fn:kim2014convolutional">8</a></sup>。
<figure>
  <img data-src="/images/cn/2020-03-28-pre-trained-model-for-nlp/convolutional-model.png" class="lazyload"/>
  <figcaption><p class="figcaption">Convolutional model</p></figcaption>
</figure></li>
<li><strong>基于序列的模型</strong>：基于序列的模型采用 RNNs（LSTM <sup class="footnote-ref" id="fnref:hochreiter1997long"><a href="#fn:hochreiter1997long">9</a></sup> 和 GRU <sup class="footnote-ref" id="fnref:chung2014empirical"><a href="#fn:chung2014empirical">10</a></sup>） 来捕获词的上下文信息。实际中，我们采用双向的 RNNs 从词的两端收集信息，不过整体效果容易收到长期依赖问题的影响。
<figure>
  <img data-src="/images/cn/2020-03-28-pre-trained-model-for-nlp/sequential-model.png" class="lazyload"/>
  <figcaption><p class="figcaption">Sequential model</p></figcaption>
</figure></li>
<li><strong>基于图的模型</strong>：基于图的模型将字作为图中的一个节点来学习上下文表示，这个图通常是一个词之间预定义的语言结构，例如：语法结构 <sup class="footnote-ref" id="fnref:socher2013recursive"><a href="#fn:socher2013recursive">11</a></sup> <sup class="footnote-ref" id="fnref:tai2015improved"><a href="#fn:tai2015improved">12</a></sup> 或语义关系 <sup class="footnote-ref" id="fnref:marcheggiani2018exploiting"><a href="#fn:marcheggiani2018exploiting">13</a></sup>。尽管基于语言学的图结构能提供有用的信息，但如何构建一个好的图结构则成为了难题。除此之外，基于语言学的图结构需要依赖专家知识和外部工具，例如：依存句法分析等。事实上，我们会采用一个更直接的方式去学习任意两个词之间的关系，通常连接的权重可以通过自注意力机制自动计算得出。Transformer <sup class="footnote-ref" id="fnref:vaswani2017attention"><a href="#fn:vaswani2017attention">14</a></sup> 是一个采用了全链接自注意力架构的实现，同时也采用了位置嵌入（positional embedding），层标准化（layer normalization）和残差连接（residual connections）等网络设计理念。
<figure>
  <img data-src="/images/cn/2020-03-28-pre-trained-model-for-nlp/fully-connected-graph-based-model.png" class="lazyload"/>
  <figcaption><p class="figcaption">Fully-connected graph-based model</p></figcaption>
</figure></li>
</ol>

<h3 id="为什么预训练">为什么预训练</h3>

<p>对于大多数的 NLP 任务，构建一个大规模的有标签的数据集是一项很大的挑战。相反，大规模的无标签语料是相对容易构建的，为了充分利用这些无标签数据，我们可以先利用它们获取一个好的语言表示，再将这些表示用于其他任务。预训练的好处如下：</p>

<ol>
<li>预训练可以从大规模语料中学习得到通用的语言表示，并用于下游任务。</li>
<li>预训练提供了更优的模型初始化方法，有助于提高模型的泛化能力和加速模型收敛。</li>
<li>预训练可以当作是在小数据集上一种避免过拟合的正则化方法。</li>
</ol>

<h3 id="预训练任务">预训练任务</h3>

<p>预训练任务对于学习语言的通用表示来说至关重要。通常情况下，预训练任务具有挑战性，同时需要大量训练数据。我们将预训练任务划分为 3 类：</p>

<ol>
<li><strong>监督学习</strong>，即从包含输入输出对的训练数据中学习一个由输入到输出的映射函数。</li>
<li><strong>非监督学习</strong>，即从无标签数据获取一些固有的知识，例如：聚类，密度，潜在表征等。</li>
<li><strong>自监督学习</strong>，是监督学习和非监督学习的混合体，核心思想是对于输入的一部分利用其他部分进行预测。</li>
</ol>

<h4 id="语言模型-language-modeling-lm">语言模型（Language Modeling，LM）</h4>

<p>NLP 中最常见的非监督任务为概率语言建模，这是一个经典的概率密度估计问题。给定一个文本序列 <code>$x_{1:T} = \left[x_1, x_2, \dotsc, x_T\right]$</code>，他的联合概率 <code>$p \left(x_{1:T}\right)$</code> 可以分解为：</p>

<p><code>$$
p \left(x_{1:T}\right) = \prod_{t=1}^{y}{p \left(x_t \mid x_{0:t-1}\right)}
$$</code></p>

<p>其中 <code>$x_0$</code> 为序列开始的特殊标记。条件概率 <code>$p \left(x_t \mid x_{0:t-1}\right)$</code> 可以通过给定的语言上下文 <code>$x_{0:t-1}$</code> 词的概率分布进行建模估计。上下文 <code>$x_{0:t-1}$</code> 可以通过神经编码器 <code>$f_{\text{enc}} \left(\cdot\right)$</code> 进行建模，则条件概率可以表示为：</p>

<p><code>$$
p \left(x_t | x_{0:t-1}\right) = g_{\text{LM}} \left(f_{\text{enc}} \left(x_{0:t-1}\right)\right)
$$</code></p>

<p>其中，<code>$g_{\text{LM}}$</code> 为预测层。</p>

<h4 id="遮罩语言模型-masked-language-modeling-mlm">遮罩语言模型（Masked Language Modeling，MLM）</h4>

<p>大致上来说，MLM 首先将输入句子的一些词条进行遮挡处理，其次再训练模型利用剩余的部分预测遮挡的部分。这种预训练方法会导致在预训练（pre-training）阶段和微调（fine-tuning）阶段的不一致，因为在微调阶段遮挡标记并未出现，BERT <sup class="footnote-ref" id="fnref:devlin2019bert"><a href="#fn:devlin2019bert">15</a></sup> 通过一个特殊的符号 <code>[MASK]</code> 对其进行处理。</p>

<h5 id="sequence-to-sequence-mlm-seq2seq-mlm">Sequence-to-Sequence MLM (Seq2Seq MLM)</h5>

<p>MLM 通常以一个分类问题进行求解，我们将遮挡后的序列输入到一个神经编码器，再将输出向量传给一个 Softmax 分类器来预测遮挡的字符。我们可以采用 Encoder-Decoder（Seq2Seq）网络结构，将遮挡的序列输入到 Encoder，Decoder 则会循序的产生被遮挡的字符。MASS <sup class="footnote-ref" id="fnref:song2019mass"><a href="#fn:song2019mass">16</a></sup> 和 T5 <sup class="footnote-ref" id="fnref:raffel2019exploring"><a href="#fn:raffel2019exploring">17</a></sup> 均采用了这种序列到序列的 MLM 结构，这种结构对 Seq2Seq 风格的下游任务很有帮助，例如：问答，摘要和机器翻译。</p>

<h5 id="enhanced-masked-language-modeling-e-mlm">Enhanced Masked Language Modeling (E-MLM)</h5>

<p>同时，大量研究对于 BERT 所使用的遮罩处理进行了改进。RoBERTa <sup class="footnote-ref" id="fnref:liu2019roberta"><a href="#fn:liu2019roberta">18</a></sup> 采用了一种动态的遮罩处理。UniLM 将遮罩任务拓展到 3 种不同的类型：单向的，双向的和 Seq2Seq 类型的。</p>

<h4 id="排列语言模型-permuted-language-modeling-plm">排列语言模型（Permuted Language Modeling，PLM）</h4>

<p>在 MLM 中一些特殊字符（例如：<code>[MASK]</code>）在下游任务中是无用的，为了解决这个问题，XLNet <sup class="footnote-ref" id="fnref:yang2019xlnet"><a href="#fn:yang2019xlnet">19</a></sup> 提出了一种排列语言模型（Permuted Language Modeling，PLM）用于替代 MLM。简言之，PLM 是对输入序列的排列进行语言建模。给定一个序列，从所有可能的排列中随机抽样得到一个排列，将排列后的序列中的一些字符作为模型的预测目标，利用其他部分和目标的自然位置进行训练。需要注意的是这种排列并不会影响序列的自然位置，其仅用于定义字符预测的顺序。</p>

<h4 id="去噪自编码-denoising-autoencoder-dae">去噪自编码（Denoising Autoencoder，DAE）</h4>

<p>DAE 旨在利用部分有损的输入恢复原始无损的输入。对于语言模型，例如 Seq2Seq 模型，可以采用标准的 Transformer 来重构原始文本。有多种方式可以对文本进行破坏 <sup class="footnote-ref" id="fnref:lewis2019bart"><a href="#fn:lewis2019bart">20</a></sup>：</p>

<ol>
<li>字符遮罩：随机采样字符并将其替换为 <code>[MASK]</code>。</li>
<li>字符删除：随机的从输入中删除字符，不同于字符遮罩，模型需要确定丢失字符的位置。</li>
<li>文本填充：采样一段文本并将其替换为一个 <code>[MASK]</code>，每段文本的长度服从泊松分布（$\lambda = 3$），模型需要确定这段文本中缺失的字符个数。</li>
<li>句子重排：将文档以终止标点进行分割，再进行随机排序。</li>
<li>文档旋转：随机均匀地选择一个字符，对文档进行旋转使得这个字符作为文档的起始字符，模型需要确定文档真实的起始位置。</li>
</ol>

<h4 id="对比学习-contrastive-learning-ctl">对比学习（Contrastive Learning，CTL）</h4>

<p>对比学习 <sup class="footnote-ref" id="fnref:saunshi2019theoretical"><a href="#fn:saunshi2019theoretical">21</a></sup> 假设一些观测到的文本对比随机采样的文本具有更相似的语义。对于文本对 <code>$\left(x, y\right)$</code> 通过最小化如下目标函数来学习评分函数 <code>$s \left(x, y\right)$</code>：</p>

<p><code>$$
\mathbb{E}_{x, y^+, y^-} \left[- \log \dfrac{\exp \left(s \left(x, y^+\right)\right)}{\exp \left(s \left(x, y^+\right)\right) + \exp \left(s \left(x, y^-\right)\right)}\right]
$$</code></p>

<p>其中，<code>$\left(x, y^+\right)$</code> 为一个相似对，<code>$y^-$</code> 对于 <code>$x$</code> 而言假定为不相似，<code>$y^+$</code> 和 <code>$y^-$</code> 通常称之为正样本和负样本。评分函数 <code>$s \left(x, y\right)$</code> 通过一个神经编码器计算可得，<code>$s \left(x, y\right) = f^{\top}_{\text{enc}} \left(x\right) f_{\text{enc}} \left(y\right)$</code> 或 <code>$s \left(x, y\right) = f_{\text{enc}} \left(x \oplus y\right)$</code>。CTL 的核心思想是“通过对比进行学习”。</p>

<p>下图展示了预训练模型的分类和部分代表模型：</p>

<link rel="stylesheet" href="/css/photoswipe.css" />
<div class="box fancy-figure caption-position-bottom caption-effect-fade" >
  <figure class="photoswipe-figure" itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/user_blogdown/images/cn/2020-03-28-pre-trained-model-for-nlp/ptms.png" alt="预训练模型分类及代表性模型"/>
    </div>
    <a href="/images/cn/2020-03-28-pre-trained-model-for-nlp/ptms.png" itemprop="contentUrl"></a>
      <figcaption>
          <p>预训练模型分类及代表性模型</p>
      </figcaption>
  </figure>
</div>


<h3 id="应用于下游任务">应用于下游任务</h3>

<h4 id="如何迁移">如何迁移</h4>

<h5 id="选择合适的预训练任务-模型架构和语料">选择合适的预训练任务，模型架构和语料</h5>

<p>不同的 PTMs 在相同的下游任务上有着不同的效果，这是因为 PTMs 有着不同的预训练任务，模型架构和语料。</p>

<ol>
<li>目前，语言模型是最流行的预训练任务，同时也可以有效地解决很多 NLP 问题。但是不同的预训练任务有着自己的侧重，在不同的任务上会有不同的效果。例如：NSP 任务使得 PTM 可以理解两句话之间的关系，因此 PTM 可以在例如问答（Question Answering，QA）和自然语言推理（Natural Language Inference，NLI）等下游任务上表现更好。</li>
<li>PTM 的网络架构对下游任务也至关重要。例如：尽管 BERT 可以处理大多数自然语言理解任务，对其很难生成语言。</li>
<li>下游任务的数据分布应该和 PTM 训练所用语料相似。目前，大量现成的 PTM 仅可以快速地用于特定领域或特定语言的下游任务上。</li>
</ol>

<h5 id="选择合适的网络层">选择合适的网络层</h5>

<p>给定一个预训练的模型，不同的网络层捕获了不同的信息，例如：词性标记（POS tagging），语法（parsing），长期依赖（long-term dependencies），语义角色（semantic roles），指代（coreference）等。Tenney <sup class="footnote-ref" id="fnref:tenney2019bert"><a href="#fn:tenney2019bert">22</a></sup> 等人发现 BERT 表示方式类似传统的 NLP 流程：基础的句法信息出现在浅层的网络中，高级的语义信息出现在更高的层级中。</p>

<p>令 <code>$\mathbf{H}^{\left(l\right)} \left(1 \leq l \leq L\right)$</code> 表示共 <code>$L$</code> 层的预训练模型的第 <code>$l$</code> 层表示，<code>$g \left(\cdot\right)$</code> 表示用于特定任务的的模型。一般有 3 中情况选择表示：</p>

<ol>
<li>Embedding Only：一种情况是仅选用预训练模型的静态嵌入，模型的其他部分仍需作为一个任务从头训练。这种情况不能够获取到一些有用的深层信息，词嵌入仅能够捕获词的语义信息。</li>
<li>Top Layer：最简单有效的方式是将网络的顶层表示输入到模型中 <code>$g \left(\mathbf{H}^{\left(L\right)}\right)$</code>。</li>
<li>All Layers：另一种更灵活的方式是自动选择最合适的层，例如 ELMo：
<code>$$
\mathbf{r}_t = \gamma \sum_{l=1}^{L}{\alpha_l \mathbf{h}^{\left(l\right)}_t}
$$</code>
其中 <code>$\alpha_l$</code> 是层 <code>$l$</code> 的 softmax 归一的权重，<code>$\gamma$</code> 是用于缩放预训练模型输出向量的一个标量值，再将不同层的混合输出输入到后续模型中 <code>$g \left(\mathbf{r}_t\right)$</code>。</li>
</ol>

<h5 id="是否微调">是否微调</h5>

<p>目前，主要有两种方式进行模型迁移：特征提取（预训练模型的参数是固定的）和模型微调（预训练模型的参数是经过微调的）。当采用特征提取时，预训练模型可以被看作是一个特征提取器。除此之外，我们应该采用内部层作为特征，因为他们通常是最适合迁移的特征。尽管两种不同方式都能对大多数 NLP 任务效果有显著提升，但以特征提取的方式需要更复杂的特定任务的架构。因此，微调是一种更加通用和方便的处理下游任务的方式。</p>

<h4 id="微调策略">微调策略</h4>

<p>随着 PTMs 网络层数的加深，其捕获的表示使得下游任务变得越来越简单，因此整个模型中用于特定任务的网络层一般比较简单，微调已经成为了采用 PTMs 的主要方式。但是微调的过程通常是比较不好预估的，即使采用相同的超参数，不同的随机数种子也可能导致差异较大的结果。除了标准的微调外，如下为一些有用的微调策略：</p>

<h5 id="两步骤微调">两步骤微调</h5>

<p>一种方式是两阶段的迁移，在预训练和微调之间引入了一个中间阶段。在第一个阶段，PTM 通过一个中间任务或语料转换为一个微调后的模型，在第二个阶段，再利用目标任务进行微调。</p>

<h5 id="多任务微调">多任务微调</h5>

<p>在多任务学习框架下对其进行微调。</p>

<h5 id="利用额外模块进行微调">利用额外模块进行微调</h5>

<p>微调的主要缺点就是其参数的低效性。每个下游模型都有其自己微调好的参数，因此一个更好的解决方案是将一些微调好的适配模块注入到 PTMs 中，同时固定原始参数。</p>

<h3 id="开放资源">开放资源</h3>

<h4 id="ptms-开源实现">PTMs 开源实现：</h4>

<table>
<thead>
<tr>
<th>项目</th>
<th>框架</th>
<th>PTMs</th>
</tr>
</thead>

<tbody>
<tr>
<td><a href="https://github.com/tmikolov/word2vec" rel="noreferrer" target="_blank">word2vec</a></td>
<td>-</td>
<td>CBOW, Skip-Gram</td>
</tr>

<tr>
<td><a href="https://nlp.stanford.edu/projects/glove" rel="noreferrer" target="_blank">GloVe</a></td>
<td>-</td>
<td>Pre-trained word vectors</td>
</tr>

<tr>
<td><a href="https://github.com/facebookresearch/fastText" rel="noreferrer" target="_blank">FastText</a></td>
<td>-</td>
<td>Pre-trained word vectors</td>
</tr>

<tr>
<td><a href="https://github.com/huggingface/transformers" rel="noreferrer" target="_blank">Transformers</a></td>
<td><i class="icon icon-pytorch">PyTorch</i> &amp; <i class="icon icon-tensorflow">TF</i></td>
<td>BERT, GPT-2, RoBERTa, XLNet, etc.</td>
</tr>

<tr>
<td><a href="https://github.com/pytorch/fairseq" rel="noreferrer" target="_blank">Fairseq</a></td>
<td><i class="icon icon-pytorch">PyTorch</i></td>
<td>English LM, German LM, RoBERTa, etc.</td>
</tr>

<tr>
<td><a href="https://github.com/ﬂairNLP/ﬂair" rel="noreferrer" target="_blank">Flair</a></td>
<td><i class="icon icon-pytorch">PyTorch</i></td>
<td>BERT, ELMo, GPT, RoBERTa, XLNet, etc.</td>
</tr>

<tr>
<td><a href="https://github.com/allenai/allennlp" rel="noreferrer" target="_blank">AllenNLP</a></td>
<td><i class="icon icon-pytorch">PyTorch</i></td>
<td>ELMo, BERT, GPT-2, etc.</td>
</tr>

<tr>
<td><a href="https://github.com/fastnlp/fastNLP" rel="noreferrer" target="_blank">FastNLP</a></td>
<td><i class="icon icon-pytorch">PyTorch</i></td>
<td>BERT, RoBERTa, GPT, etc.</td>
</tr>

<tr>
<td><a href="https://github.com/ymcui/Chinese-BERT-wwm" rel="noreferrer" target="_blank">Chinese-BERT</a></td>
<td>-</td>
<td>BERT, RoBERTa, etc. (for Chinese)</td>
</tr>

<tr>
<td><a href="https://github.com/google-research/bert" rel="noreferrer" target="_blank">BERT</a></td>
<td><i class="icon icon-tensorflow">TF</i></td>
<td>BERT, BERT-wwm</td>
</tr>

<tr>
<td><a href="https://github.com/pytorch/fairseq/tree/master/examples/roberta" rel="noreferrer" target="_blank">RoBERTa</a></td>
<td><i class="icon icon-pytorch">PyTorch</i></td>
<td></td>
</tr>

<tr>
<td><a href="https://github.com/zihangdai/xlnet" rel="noreferrer" target="_blank">XLNet</a></td>
<td><i class="icon icon-tensorflow">TF</i></td>
<td></td>
</tr>

<tr>
<td><a href="https://github.com/google-research/ALBERT" rel="noreferrer" target="_blank">ALBERT</a></td>
<td><i class="icon icon-tensorflow">TF</i></td>
<td></td>
</tr>

<tr>
<td><a href="https://github.com/google-research/text-to-text-transfer-transformer" rel="noreferrer" target="_blank">T5</a></td>
<td><i class="icon icon-tensorflow">TF</i></td>
<td></td>
</tr>

<tr>
<td><a href="https://github.com/thunlp/ERNIE" rel="noreferrer" target="_blank">ERNIE(THU)</a></td>
<td><i class="icon icon-pytorch">PyTorch</i></td>
<td></td>
</tr>

<tr>
<td><a href="https://github.com/PaddlePaddle/ERNIE" rel="noreferrer" target="_blank">ERNIE(Baidu)</a></td>
<td><i class="icon icon-paddlepaddle"></i> PaddlePaddle</td>
<td></td>
</tr>

<tr>
<td><a href="https://github.com/huggingface/transformers" rel="noreferrer" target="_blank">Hugging Face</a></td>
<td><i class="icon icon-pytorch">PyTorch</i> &amp; <i class="icon icon-tensorflow">TF</i></td>
<td>很多&hellip;</td>
</tr>
</tbody>
</table>

<h4 id="论文列表和-ptms-相关资源">论文列表和 PTMs 相关资源：</h4>

<table>
<thead>
<tr>
<th>资源</th>
<th>URL</th>
</tr>
</thead>

<tbody>
<tr>
<td>论文列表</td>
<td><a href="https://github.com/thunlp/PLMpapers" rel="noreferrer" target="_blank">https://github.com/thunlp/PLMpapers</a></td>
</tr>

<tr>
<td>论文列表</td>
<td><a href="https://github.com/tomohideshibata/BERT-related-papers" rel="noreferrer" target="_blank">https://github.com/tomohideshibata/BERT-related-papers</a></td>
</tr>

<tr>
<td>论文列表</td>
<td><a href="https://github.com/cedrickchee/awesome-bert-nlp" rel="noreferrer" target="_blank">https://github.com/cedrickchee/awesome-bert-nlp</a></td>
</tr>

<tr>
<td>Bert Lang Street</td>
<td><a href="https://bertlang.unibocconi.it" rel="noreferrer" target="_blank">https://bertlang.unibocconi.it</a></td>
</tr>

<tr>
<td>BertViz</td>
<td><a href="https://github.com/jessevig/bertviz" rel="noreferrer" target="_blank">https://github.com/jessevig/bertviz</a></td>
</tr>
</tbody>
</table>

<h2 id="预训练模型">预训练模型</h2>

<h3 id="cove-2017-mccann2017learned">CoVe (2017) <sup class="footnote-ref" id="fnref:mccann2017learned"><a href="#fn:mccann2017learned">4</a></sup></h3>

<p>首先，给定一个源语言序列 <code>$w^x = \left[w^x_1, \dotsc, w^x_n\right]$</code> 和一个翻译目标语言序列 <code>$w^z = \left[w^z_1, \dotsc, w^z_n\right]$</code>。令 <code>$\text{GloVe} \left(w^x\right)$</code> 为词 <code>$w^x$</code> 对应的 GloVe 向量，<code>$z$</code> 为 <code>$w^z$</code> 中的词随机初始化的词向量。将 <code>$\text{GloVe} \left(w^x\right)$</code> 输入到一个标准的两层 biLSTM 网络中，称之为 MT-LSTM，MT-LSTM 用于计算序列的隐含状态如下：</p>

<p><code>$$
h = \text{MT-LSTM} \left(\text{GloVe} \left(w^x\right)\right)
$$</code></p>

<p>对于机器翻译，MT-LSTM 的注意力机制的解码器可以对于输出的词在每一步产生一个分布 <code>$p \left(\hat{w}^z_t \mid H, w^z_1, \dotsc, w^z_{t-1}\right)$</code>。在 <code>$t$</code> 步，解码器利用一个两层的单向 LSTM 基于之前目标词嵌入 <code>$z_{t-1}$</code> 和一个基于上下文调整的隐含状态 <code>$\tilde{h}_{t-1}$</code> 生成一个隐含状态 <code>$h^{\text{dec}}_t$</code>：</p>

<p><code>$$
h^{\text{dec}}_t = \text{LSTM} \left(\left[z_{t-1}; \tilde{h}_{t-1}\right], h^{\text{dec}}_{t-1}\right)
$$</code></p>

<p>之后解码器计算每一步编码到当前解码状态的注意力权重 <code>$\alpha$</code>：</p>

<p><code>$$
\alpha_t = \text{softmax} \left(H \left(W_1 h^{\text{dec}}_t + b_1\right)\right)
$$</code></p>

<p>其中 <code>$H$</code> 表示 <code>$h$</code> 按照时间维度的堆叠。之后解码器将这些权重作为相关性用于计算基于上下文调整的隐含状态 <code>$\tilde{h}$</code>：</p>

<p><code>$$
\tilde{h}_t = \text{tanh} \left(W_2 \left[H^{\top} \alpha_t; h^{\text{dec}}_t\right] + b_2\right)
$$</code></p>

<p>最后，输出词的分布通过基于上下文调整的隐含状态计算可得：</p>

<p><code>$$
p \left(\hat{w}^z_t \mid H, w^z_1, \dotsc, w^z_{t-1}\right) = \text{softmax} \left(W_{\text{out}} \tilde{h}_t + b_{\text{out}}\right)
$$</code></p>

<p>CoVe 将 MT-LSTM 学习到的表示迁移到下游任务中，令 <code>$w$</code> 表示文字序列，<code>$\text{GloVe} \left(w\right)$</code> 表示对应的 GloVe 向量，则：</p>

<p><code>$$
\text{CoVe} \left(w\right) = \text{MT-LSTM} \left(\text{GloVe} \left(w\right)\right)
$$</code></p>

<p>表示由 MT-LSTM 产生的上下文向量，对于分类和问答任务，有一个输入序列 <code>$w$</code>，我们可以将 GloVe 和 CoVe 向量进行拼接作为其嵌入表示：</p>

<p><code>$$
\tilde{w} = \left[\text{GloVe} \left(w\right); \text{CoVe} \left(w\right)\right]
$$</code></p>

<p>CoVe 网络架构示意图如下：</p>

<figure>
  <img data-src="/images/cn/2020-03-28-pre-trained-model-for-nlp/cove.png" class="lazyload"/>
  
</figure>

<h3 id="elmo-2018-peters2018deep">ELMo (2018) <sup class="footnote-ref" id="fnref:peters2018deep"><a href="#fn:peters2018deep">5</a></sup></h3>

<p>在 ELMo 模型中，对于每个词条 <code>$t_k$</code>，一个 <code>$L$</code> 层的 biLM 可以计算得到 <code>$2L + 1$</code> 个表示：</p>

<p><code>$$
\begin{aligned}
R_k &amp;= \left\{\mathbf{x}^{LM}_k, \overrightarrow{\mathbf{h}}^{LM}_{k, j}, \overleftarrow{\mathbf{h}}^{LM}_{k, j} \mid j = 1, \dotsc, L \right\} \\
&amp;= \left\{\mathbf{h}^{LM}_{k, j} \mid j = 0, \dotsc, L\right\}
\end{aligned}
$$</code></p>

<p>其中 <code>$\mathbf{h}^{LM}_{k, 0}$</code> 为词条的嵌入层，<code>$\mathbf{h}^{LM}_{k, j} = \left[\overrightarrow{\mathbf{h}}^{LM}_{k, j}; \overleftarrow{\mathbf{h}}^{LM}_{k, j}\right]$</code> 为每个 biLSTM 层。</p>

<p>对于下游任务，ELMo 将 <code>$R$</code> 中的所有层汇总成一个向量 <code>$\mathbf{ELMo}_k = E \left(R_k; \mathbf{\Theta}_e\right)$</code>。在一些简单的案例中，ELMo 仅选择顶层，即：<code>$E \left(R_k\right) = \mathbf{h}^{LM}_{k, L}$</code>。更通用的，对于一个特定的任务，我们可以计算一个所有 biLM 层的加权：</p>

<p><code>$$
\mathbf{ELMo}^{task}_k = E \left(R_k; \Theta^{task}\right) = \gamma^{task} \sum_{j=0}^{L}{s^{task}_j \mathbf{h}^{LM}_{k, j}}
$$</code></p>

<p>其中，<code>$s^{task}$</code> 表示 softmax 归一化后的权重，<code>$\gamma^{task}$</code> 允许模型对整个 ELMo 向量进行缩放。<code>$\gamma$</code> 对整个优化过程具有重要意义，考虑每个 biLM 层的激活具有不同的分布，在一些情况下这相当于在进行加权之前对每一个 biLM 层增加了层标准化。</p>

<p>ELMo 网络架构示意图如下 <sup class="footnote-ref" id="fnref:elmo"><a href="#fn:elmo">23</a></sup>：</p>

<figure>
  <img data-src="/images/cn/2020-03-28-pre-trained-model-for-nlp/elmo.png" class="lazyload"/>
  
</figure>

<h3 id="gpt-2018-radford2018improving">GPT (2018) <sup class="footnote-ref" id="fnref:radford2018improving"><a href="#fn:radford2018improving">6</a></sup></h3>

<p>给定一个语料 <code>$\mathcal{U} = \left\{u_1, \dotsc, u_n\right\}$</code>，使用标准的语言建模目标来最大化如下似然：</p>

<p><code>$$
L_1 \left(\mathcal{U}\right) = \sum_{i} \log P \left(u_i \mid u_{i-k}, \dotsc, u_{i-1}; \Theta\right)
$$</code></p>

<p>其中，<code>$k$</code> 为上下文窗口的大小，条件概率 <code>$P$</code> 通过参数为 <code>$\Theta$</code> 的神经网络进行建模。GPT 中使用了一个多层的 Transformer Decoder 作为语言模型。模型首先对输入上下文词条应用多头自注意力机制，再通过按位置的前馈层产生目标词条的输出分布：</p>

<p><code>$$
\begin{aligned}
h_0 &amp;= UW_e + W_p \\
h_l &amp;= \text{transformer_black} \left(h_{l-1}\right), \forall i \in \left[1, n\right] \\
P \left(u\right) &amp;= \text{softmax} \left(h_n W^{\top}_e\right)
\end{aligned}
$$</code></p>

<p>其中，<code>$U = \left(u_{-k}, \dotsc, u_{-1}\right)$</code> 为词条的上下文向量，<code>$n$</code> 为网络层数，<code>$W_e$</code> 为词条的嵌入矩阵，<code>$W_p$</code> 为位置嵌入矩阵。</p>

<p>给定一个有标签的数据集 <code>$\mathcal{C}$</code>，其中包含了输入词条序列 <code>$x^1, \dotsc, x^m$</code> 和对应的标签 <code>$y$</code>。利用上述预训练的模型获得输入对应的最后一个 Transformer 的激活输出 <code>$h^m_l$</code>，之后再将其输入到一个参数为 <code>$W_y$</code> 的线性输入层中预测 <code>$y$</code>：</p>

<p><code>$$
P \left(y \mid x^1, \dotsc, x^m\right) = \text{softmax} \left(h^m_l W_y\right)
$$</code></p>

<p>模型通过最小化如下损失进行优化：</p>

<p><code>$$
L_2 \left(\mathcal{C}\right) = \sum_{\left(x, y\right)} \log P \left(y \mid x^1, \dotsc, x^m\right)
$$</code></p>

<p>研究还发现将语言建模作为微调的附加目标可以帮助提高模型的泛化能力，同时可以加速模型收敛。GPT 中采用如下的优化目标：</p>

<p><code>$$
L_3 \left(\mathcal{C}\right) = L_2 \left(\mathcal{C}\right) + \lambda L_1 \left(\mathcal{C}\right)
$$</code></p>

<p>GPT 网络架构示意图如下：</p>

<figure>
  <img data-src="/images/cn/2020-03-28-pre-trained-model-for-nlp/gpt.png" class="lazyload"/>
  
</figure>

<h3 id="bert-2018-devlin2018bert">BERT (2018) <sup class="footnote-ref" id="fnref:devlin2018bert"><a href="#fn:devlin2018bert">7</a></sup></h3>

<p>BERT 采用了一中基于 Vaswani <sup class="footnote-ref" id="fnref:vaswani2017attention"><a href="#fn:vaswani2017attention">14</a></sup> 所提出模型的多层双向 Transformer 编码器。在 BERT 中，令 <code>$L$</code> 为 Transformer Block 的层数，<code>$H$</code> 为隐层大小，<code>$A$</code> 为自注意力头的数量。在所有情况中，设置前馈层的大小为 <code>$4H$</code>，BERT 提供了两种不同大小的预训练模型：</p>

<ul>
<li><code>$\text{BERT}_{\text{BASE}}$</code>：<code>$L=12, H=768, A=12$</code>，参数总量为 100 M。</li>
<li><code>$\text{BERT}_{\text{LARGE}}$</code>：<code>$L=24, H=1024, A=16$</code>，参数总量为 340 M。</li>
</ul>

<p><code>$\text{BERT}_{\text{BASE}}$</code> 采用了同 GPT 相同的模型大小用于比较，不同与 GPT，BERT 使用了双向的注意力机制。在文献中，双向 Transformer 通常称之为 Transformer 编码器，仅利用左边上下文信息的 Transformer 由于可以用于文本生成被称之为 Transformer 解码器。BERT，GPT 和 ELMo 之间的不同如下图所示：</p>

<figure>
  <img data-src="/images/cn/2020-03-28-pre-trained-model-for-nlp/bert-gpt-elmo-model-architectures.png" class="lazyload"/>
  
</figure>

<p>BERT 的输入表示既可以表示一个单独的文本序列，也可以表示一对文本序列（例如：问题和答案）。对于一个给定的词条，其输入表示由对应的词条嵌入，分割嵌入和位置嵌入三部分加和构成，如下图所示：</p>

<figure>
  <img data-src="/images/cn/2020-03-28-pre-trained-model-for-nlp/bert-input-representation.png" class="lazyload"/>
  
</figure>

<p>具体的有：</p>

<ul>
<li>采用一个包含 30,000 个词条的 WordPiece 嵌入 <sup class="footnote-ref" id="fnref:wu2016google"><a href="#fn:wu2016google">24</a></sup>。</li>
<li>位置嵌入最大支持 512 个词条。</li>
<li>序列的第一字符采用特殊的分类嵌入 <code>[CLS]</code>，其最终的隐含状态在分类任务中用于汇总整个序列的表示，对于非分类任务则忽视该向量。</li>
<li>句子对被整合成一个序列，首先利用一个特殊词条 <code>[SEP]</code> 对句子进行分割，其次对于第一个句子中的每个词条叠加一个学习到的 A 句子嵌入，对于第二个句子中的每个词条叠加一个学习到的 B 句子嵌入。</li>
<li>对于一个单独的句子，仅使用 A 句子嵌入。</li>
</ul>

<p>在预训练阶段，BERT 采用了两个无监督预测任务：</p>

<ol>
<li>遮罩的语言模型（Masked LM，MLM）<br />
不同于一般的仅利用 <code>[MASK]</code> 进行遮挡，BERT 选择采用 80% 的 <code>[MASK]</code>，10% 的随机词和 10% 保留原始词的方式对随机选择的 15% 的词条进行遮挡处理。由于编码器不知会预测哪个词或哪个词被随机替换了，这迫使其必须保留每个输入词条的分布式上下文表示。同时 1.5% 的随机替换也不会过多的损害模型的理解能力。<br /></li>
<li>预测是否为下一个句子（Next Sentence Prediction）<br />
一些重要的下游任务，例如问答（Question Answering，QA）和自然语言推断（Natural Language Inference，NLI）是基于两个句子之间关系的理解，这是语言建模无法直接捕获的。BERT 通过训练一个预测是否为下一个句子的二分类任务来实现，对于一个句子对 A 和 B，50% 的 B 是句子 A 真实的下一句，剩余 50% 为随机抽取的。</li>
</ol>

<p>基于 BERT 的不同下游任务的实现形式如下图所示：</p>

<figure>
  <img data-src="/images/cn/2020-03-28-pre-trained-model-for-nlp/bert-task-specific-models.png" class="lazyload"/>
  
</figure>

<h3 id="unilm-2019-dong2019unified">UniLM (2019) <sup class="footnote-ref" id="fnref:dong2019unified"><a href="#fn:dong2019unified">25</a></sup></h3>

<p>给定一个输入序列 <code>$x = x_1 \cdots x_{|x|}$</code>，UniLM 通过下图的方式获取每个词条的基于上下文的向量表示。整个预训练过程利用单向的语言建模（unidirectional LM），双向的语言建模（bidirectional LM）和 Seq2Seq 语言建模（sequence-to-sequence LM）优化共享的 Transformer 网络。</p>

<figure>
  <img data-src="/images/cn/2020-03-28-pre-trained-model-for-nlp/unilm.png" class="lazyload"/>
  
</figure>

<p>输入序列 <code>$x$</code> 对于单向语言模型而言是一个分割的文本，对于双向语言模型和 Seq2Seq 语言模型而言是一对打包的分割文本。UniLM 在输入的起始位置添加特殊的 <code>[SOS]</code> （start-of-sequence），在结尾处添加 <code>[EOS]</code>（end-of-sequence）。<code>[EOS]</code> 对于自然语言理解（NLU）任务可以标记句子之间的界线，对于自然语言生成（NLG）任务可以确定解码过程停止的时间。输入的表示同 BERT 一样，文本利用 WordPiece 进行分割，对于每个输入词条，其向量表示为对应的词条嵌入，位置嵌入和分割嵌入的汇总。</p>

<p>对于输入向量 <code>$\left\{\mathbf{x}_i\right\}^{|x|}_{i=1}$</code> 首先将其输入到隐层 <code>$\mathbf{H}^0 = \left[\mathbf{x}_1, \dotsc, \mathbf{x}_{|x|}\right]$</code>，之后使用一个 <code>$L$</code> 层的 Transformer <code>$\mathbf{H}^l = \text{Transformer}_l \left(\mathbf{H}^{l-1}\right), l \in \left[1, L\right]$</code> 对每一层 <code>$\mathbf{H}^l = \left[\mathbf{h}^l_1, \dotsc, \mathbf{h}^l_{|x|}\right]$</code> 进行上下文表示编码。在每个 Tansformer 块中，使用多头自注意力机制对输出向量和上一层进行汇总，第 <code>$l$</code> 层 Transformer 自注意力头 <code>$\mathbf{A}_l$</code> 的输入通过如下方式计算：</p>

<p><code>$$
\begin{aligned}
\mathbf{Q} &amp;= \mathbf{H}^{l-1} \mathbf{W}^Q_l, \mathbf{K} = \mathbf{H}^{l-1} \mathbf{W}^K_l, \mathbf{V} = \mathbf{H}^{l-1} \mathbf{W}^W_l \\
\mathbf{M}_{ij} &amp;= 
\begin{cases}
0, &amp; \text{allow to attend} \\
- \infty, &amp; \text{prevent from attending}
\end{cases} \\
\mathbf{A}_l &amp;= \text{softmax} \left(\dfrac{\mathbf{Q} \mathbf{K}^{\top}}{\sqrt{d_k}} + \mathbf{M}\right) \mathbf{V}_l
\end{aligned}
$$</code></p>

<p>其中，上一层的输出 <code>$\mathbf{H}^{l-1} \in \mathbb{R}^{|x| \times d_h}$</code> 通过参数矩阵 <code>$\mathbf{W}^Q_l, \mathbf{W}^K_l, \mathbf{W}^V_l \in \mathbb{R}^{d_h \times d_k}$</code> 线性地映射为相应的 Query，Key 和 Value，遮罩矩阵 <code>$\mathbf{M} \in \mathbb{R}^{|x| \times |x|}$</code> 用于确定一对词条是否可以被相互连接。</p>

<h3 id="transformer-xl-2019-dai2019transformer">Transformer-XL (2019) <sup class="footnote-ref" id="fnref:dai2019transformer"><a href="#fn:dai2019transformer">26</a></sup></h3>

<p>将 Transformer 或注意力机制应用到语言建模中的核心问题是如何训练 Transformer 使其有效地将一个任意长文本编码为一个固定长度的表示。Transformer-XL 将整个语料拆分为较短的段落，仅利用每段进行训练并忽略之前段落的上下文信息。这种方式称之为 Vanilla Model <sup class="footnote-ref" id="fnref:airfou2019character"><a href="#fn:airfou2019character">27</a></sup>，如下图所示：</p>

<figure>
  <img data-src="/images/cn/2020-03-28-pre-trained-model-for-nlp/transformer-xl-vanilla-model.png" class="lazyload"/>
  
</figure>

<p>在这种训练模式下，无论是前向还是后向信息都不会跨越分割的段落进行传导。利用固定长度的上下文主要有两个弊端：</p>

<ol>
<li>这限制了最大依赖的长度，虽然自注意力机制不会像 RNN 一样受到梯度弥散的影响，但 Vanilla Model 也不能完全利用到这个优势。</li>
<li>虽然可以利用补全操作来实现句子或其他语义的分割，但实际上通常会简单的将一个长文本截断成一个固定长度的分割，这样会产生上下文分裂破碎的问题。</li>
</ol>

<p>为了解决这个问题，Transformer-XL 采用了一种循环机制的 Transformer。在训练阶段，在处理新的分割段落时，之前分割分部分的隐含状态序列将被<strong>固定（fixed）</strong>和<strong>缓存（cached）</strong>下来作为一个扩展的上下文被复用参与计算，如下图所示：</p>

<figure>
  <img data-src="/images/cn/2020-03-28-pre-trained-model-for-nlp/transformer-xl-model.png" class="lazyload"/>
  
</figure>

<p>虽然梯度仍仅限于这个分割段落内部，但网络可以从历史中获取信息，从而实现对长期依赖的建模。令两个长度为 <code>$L$</code> 的连续分割段落为 <code>$\mathbf{s}_{\tau} = \left[x_{\tau, 1}, \dotsc, x_{\tau, L}\right]$</code> 和 <code>$\mathbf{s}_{\tau + 1} = \left[x_{\tau + 1, 1}, \dotsc, x_{\tau + 1, L}\right]$</code>，第 <code>$\tau$</code> 段分割 <code>$\mathbf{s}_{\tau}$</code> 的第 <code>$n$</code> 层隐含状态为 <code>$\mathbf{h}^n_{\tau} \in \mathbb{R}^{L \times d}$</code>，其中 <code>$d$</code> 为隐含维度。则对于分割段落 <code>$\mathbf{s}_{\tau + 1}$</code> 的第 <code>$n$</code> 层隐含状态通过如下方式进行计算：</p>

<p><code>$$
\begin{aligned}
\tilde{\mathbf{h}}^{n-1}_{\tau + 1} &amp;= \left[\text{SG} \left(\mathbf{h}^{n-1}_{\tau}\right) \circ \mathbf{h}^{n-1}_{\tau + 1} \right] \\
\mathbf{q}^{n}_{\tau + 1}, \mathbf{k}^{n}_{\tau + 1}, \mathbf{v}^{n}_{\tau + 1} &amp;= \mathbf{h}^{n-1}_{\tau + 1} \mathbf{W}^{\top}_{q}, \tilde{\mathbf{h}}^{n-1}_{\tau + 1} \mathbf{W}^{\top}_{k}, \tilde{\mathbf{h}}^{n-1}_{\tau + 1} \mathbf{W}^{\top}_{v} \\
\mathbf{h}^{n}_{\tau + 1} &amp;= \text{Transformer-Layer} \left(\mathbf{q}^{n}_{\tau + 1}, \mathbf{k}^{n}_{\tau + 1}, \mathbf{v}^{n}_{\tau + 1}\right)
\end{aligned}
$$</code></p>

<p>其中，<code>$\text{SG} \left(\cdot\right)$</code> 表示停止梯度，<code>$\left[\mathbf{h}_u \circ \mathbf{h}_v\right]$</code> 表示将两个隐含序列按照长度维度进行拼接，<code>$\mathbf{W}$</code> 为模型的参数。与一般的 Transformer 相比，最大的不同在于 <code>$\mathbf{k}^n_{\tau + 1}$</code> 和 <code>$\mathbf{v}^n_{\tau + 1}$</code> 不仅依赖于 <code>$\tilde{\mathbf{h}}^{n-1}_{\tau - 1}$</code> 还依赖于之前分割段落的 <code>$\mathbf{h}^{n-1}_{\tau}$</code> 缓存。</p>

<p>在标准的 Transformer 中，序列的顺序信息通过位置嵌入 <code>$\mathbf{U} \in \mathbb{R}^{L_{\max} \times d}$</code> 提供，其中第 <code>$i$</code> 行 <code>$\mathbf{U}_i$</code> 对应一个分割文本内部的第 <code>$i$</code> 个<strong>绝对</strong>位置，<code>$L_{\max}$</code> 为最大可能长度。在 Transformer-XL 中则是通过一种<strong>相对</strong>位置信息对其进行编码，构建一个相对位置嵌入 <code>$\mathbf{R} \in \mathbb{R} ^{L_{\max} \times d}$</code>，其中第 <code>$i$</code> 行 <code>$\mathbf{R}_i$</code> 表示两个位置之间相对距离为 <code>$i$</code> 的嵌入表示。</p>

<p>对于一般的 Transformer，一个分割段落内部的 <code>$q_i$</code> 和 <code>$k_j$</code> 之间的注意力分数可以分解为：</p>

<p><code>$$
\begin{aligned}
\mathbf{A}_{i, j}^{\mathrm{abs}} &amp;=\underbrace{\mathbf{E}_{x_{i}}^{\top} \mathbf{W}_{q}^{\top} \mathbf{W}_{k} \mathbf{E}_{x_{j}}}_{(a)}+\underbrace{\mathbf{E}_{x_{i}}^{\top} \mathbf{W}_{q}^{\top} \mathbf{W}_{k} \mathbf{U}_{j}}_{(b)} \\
&amp;+\underbrace{\mathbf{U}_{i}^{\top} \mathbf{W}_{q}^{\top} \mathbf{W}_{k} \mathbf{E}_{x_{j}}}_{(c)}+\underbrace{\mathbf{U}_{i}^{\top} \mathbf{W}_{q}^{\top} \mathbf{W}_{k} \mathbf{U}_{j}}_{(d)}
\end{aligned}
$$</code></p>

<p>利用相对位置思想，变化如下：</p>

<p><code>$$
\begin{aligned}
\mathbf{A}_{i, j}^{\mathrm{rel}} &amp;=\underbrace{\mathbf{E}_{x_{i}}^{\top} \mathbf{W}_{q}^{\top} \mathbf{W}_{k, E} \mathbf{E}_{x_{j}}}_{(a)}+\underbrace{\mathbf{E}_{x_{i}}^{\top} \mathbf{W}_{q}^{\top} \mathbf{W}_{k, R} \textcolor{blue}{\mathbf{R}_{i-j}}}_{(b)} \\
&amp;+\underbrace{\textcolor{red}{u^{\top}} \mathbf{W}_{k, E} \mathbf{E}_{x_{j}}}_{(c)}+\underbrace{\textcolor{red}{v^{\top}} \mathbf{W}_{k, R} \textcolor{blue}{\mathbf{R}_{i-j}}}_{(d)}
\end{aligned}
$$</code></p>

<ol>
<li>首先，利用相对位置 <code>$\textcolor{blue}{\mathbf{R}_{i-j}}$</code> 替代绝对位置嵌入 <code>$\mathbf{U}_j$</code>，这里 <code>$\mathbf{R}$</code> 采用的是无需学习的 sinusoid 编码矩阵 <sup class="footnote-ref" id="fnref:vaswani2017attention"><a href="#fn:vaswani2017attention">14</a></sup>。</li>
<li>其次，引入了一个可训练的参数 <code>$\textcolor{red}{u} \in \mathbb{R}^d$</code> 用于替换 <code>$\mathbf{U}^{\top}_i \mathbf{W}^{\top}_q$</code>。类似的，对于 <code>$\mathbf{U}^{\top} \mathbf{W}^{\top}_q$</code> 使用一个可训练的 <code>$\textcolor{red}{v} \in \mathbb{R}^d$</code> 替换。</li>
<li>最后，有意地划分了两个权重矩阵 <code>$\mathbf{W}_{k, E}$</code> 和 <code>$\mathbf{W}_{k, R}$</code> 用于生成基于内容的 Key 向量和基于位置的 Key 向量。</li>
</ol>

<p>这样，<code>$\left(a\right)$</code> 代表了基于内容的位置信息，<code>$\left(b\right)$</code> 捕获了内容无关的位置偏置，<code>$\left(c\right)$</code> 表示了一个全局的内容偏置，<code>$\left(d\right)$</code> 捕获了一个全局的位置偏置。</p>

<p>利用一个自注意力头计算 <code>$N$</code> 层的 Transformer-XL 的过程如下，对于 <code>$n = 1, \dotsc, N$</code> 有：</p>

<p><code>$$
\begin{aligned}
\widetilde{\mathbf{h}}_{\tau}^{n-1}=&amp;\left[\mathrm{SG}\left(\mathbf{m}_{\tau}^{n-1}\right) \circ \mathbf{h}_{\tau}^{n-1}\right] \\
\mathbf{q}_{\tau}^{n}, \mathbf{k}_{\tau}^{n}, \mathbf{v}_{\tau}^{n}=&amp; \mathbf{h}_{\tau}^{n-1} {\mathbf{W}_{q}^{n}}^{\top}, \widetilde{\mathbf{h}}_{\tau}^{n-1} {\mathbf{W}_{k, E}^{n}}^{\top}, \widetilde{\mathbf{h}}_{\tau}^{n-1} {\mathbf{W}_{v}^{n}}^{\top} \\
\mathbf{A}_{\tau, i, j}^{n}=&amp; {\mathbf{q}_{\tau, i}^{n}}^{\top} \mathbf{k}_{\tau, j}^{n} + {\mathbf{q}_{\tau, i}^{n}}^{\top} \mathbf{W}_{k, R}^{n} \mathbf{R}_{i-j} \\
&amp;+u^{\top} \mathbf{k}_{\tau, j}+v^{\top} \mathbf{W}_{k, R}^{n} \mathbf{R}_{i-j} \\
\mathbf{a}_{\tau}^{n}=&amp; \text { Masked-Softmax }\left(\mathbf{A}_{\tau}^{n}\right) \mathbf{v}_{\tau}^{n} \\
\mathbf{o}_{\tau}^{n}=&amp; \text { LayerNorm } \left(\text{Linear}\left(\mathbf{a}_{\tau}^{n}\right)+\mathbf{h}_{\tau}^{n-1}\right) \\
\mathbf{h}_{\tau}^{n}=&amp; \text { Positionwise-Feed-Forward }\left(\mathbf{o}_{\tau}^{n}\right)
\end{aligned}
$$</code></p>

<h3 id="xlnet-2019-yang2019xlnet">XLNet (2019) <sup class="footnote-ref" id="fnref:yang2019xlnet"><a href="#fn:yang2019xlnet">19</a></sup></h3>

<p>给定一个序列 <code>$\mathbf{X} = \left[x_1, \dotsc, x_T\right]$</code>，AR 语言模型通过最大化如下似然进行预训练：</p>

<p><code>$$
\max_{\theta} \quad \log p_{\theta}(\mathbf{x})=\sum_{t=1}^{T} \log p_{\theta}\left(x_{t} | \mathbf{x}_{&lt;t}\right)=\sum_{t=1}^{T} \log \frac{\exp \left(h_{\theta}\left(\mathbf{x}_{1: t-1}\right)^{\top} e\left(x_{t}\right)\right)}{\sum_{x^{\prime}} \exp \left(h_{\theta}\left(\mathbf{x}_{1: t-1}\right)^{\top} e\left(x^{\prime}\right)\right)}
$$</code></p>

<p>其中，<code>$h_{\theta}\left(\mathbf{x}_{1: t-1}\right)$</code> 是由 RNNs 或 Transformer 等神经网络网络模型生成的上下文表示，<code>$e \left(x\right)$</code> 为 <code>$x$</code> 的嵌入。对于一个文本序列 <code>$\mathbf{x}$</code>，BERT 首先构建了一个遮罩的数据集 <code>$\hat{\mathbf{x}}$</code>，令被遮挡的词条为 <code>$\overline{\mathbf{x}}$</code>，通过训练如下目标来利用 <code>$\hat{\mathbf{x}}$</code> 重构 <code>$\overline{\mathbf{x}}$</code>：</p>

<p><code>$$
\max_{\theta} \quad \log p_{\theta}(\overline{\mathbf{x}} | \hat{\mathbf{x}}) \approx \sum_{t=1}^{T} m_{t} \log p_{\theta}\left(x_{t} | \hat{\mathbf{x}}\right)=\sum_{t=1}^{T} m_{t} \log \frac{\exp \left(H_{\theta}(\hat{\mathbf{x}})_{t}^{\top} e\left(x_{t}\right)\right)}{\sum_{x^{\prime}} \exp \left(H_{\theta}(\hat{\mathbf{x}})_{t}^{\top} e\left(x^{\prime}\right)\right)}
$$</code></p>

<p>其中 <code>$m_t = 1$</code> 表示 <code>$x_t$</code> 是被遮挡的，<code>$H_{\theta}$</code> 是一个 Transformer 将一个长度为 <code>$T$</code> 的文本序列映射到一个隐含向量序列 <code>$H_{\theta}(\mathbf{x})=\left[H_{\theta}(\mathbf{x})_{1}, H_{\theta}(\mathbf{x})_{2}, \cdots, H_{\theta}(\mathbf{x})_{T}\right]$</code>。两种不同的预训练目标的优劣势如下</p>

<ol>
<li><strong>独立假设</strong>：BERT 中联合条件概率 <code>$p(\overline{\mathbf{x}} | \hat{\mathbf{x}})$</code> 假设在给定的 <code>$\hat{\mathbf{x}}$</code> 下，遮挡的词条 <code>$\overline{\mathbf{x}}$</code> 是相关独立的，而 AR 语言模型则没有这样的假设。</li>
<li><strong>输入噪声</strong>：BERT 在预训练是使用了特殊标记 <code>[MASK]</code>，在下游任务微调时不会出现，而 AR 语言模型则不会存在这个问题。</li>
<li><strong>上下文依赖</strong>：AR 语言模型仅考虑了词条左侧的上下文，而 BERT 则可以捕获两个方向的上下文。</li>
</ol>

<p>为了利用 AR 语言模型和 BERT 的优点，XLNet 提出了排序语言模型。对于一个长度为 <code>$T$</code> 序列 <code>$\mathbf{x}$</code>，共有 <code>$T!$</code> 种不同的方式进行 AR 分解，如果模型共享不同分解顺序的参数，那么模型就能学习到两侧所有位置的信息。令 <code>$\mathcal{Z}_T$</code> 为长度为 <code>$T$</code> 的索引序列 <code>$\left[1, 2, \dotsc, T\right]$</code> 的所有可能排列，<code>$z_t$</code> 和 <code>$\mathbf{z}_{&lt;t}$</code> 分别表示一个排列 <code>$\mathbf{z} \in \mathcal{Z}_T$</code> 第 <code>$t$</code> 个和前 <code>$t-1$</code> 个元素。则排列语言模型的优化目标为：</p>

<p><code>$$
\max_{\theta} \quad \mathbb{E}_{\mathbf{z} \sim \mathcal{Z}_{T}}\left[\sum_{t=1}^{T} \log p_{\theta}\left(x_{z_{t}} | \mathbf{x}_{\mathbf{z}_{&lt;t}}\right)\right]
$$</code></p>

<p>根据标准的 Transformer，下一个词条的分布 <code>$p_{\theta}\left(X_{z_{t}} | \mathbf{x}_{\mathbf{z}&lt;t}\right)$</code> 为：</p>

<p><code>$$
p_{\theta}\left(X_{z_{t}} = x | \mathbf{x}_{\mathbf{z}&lt;t}\right)=\frac{\exp \left(e(x)^{\top} h_{\theta}\left(\mathbf{x}_{\mathbf{z}&lt;t}\right)\right)}{\sum_{x^{\prime}} \exp \left(e\left(x^{\prime}\right)^{\top} h_{\theta}\left(\mathbf{x}_{\mathbf{z}&lt;t}\right)\right)}
$$</code></p>

<p>其中，<code>$h_{\theta}\left(\mathbf{x}_{\mathbf{z}&lt;t}\right)$</code> 表示通过共享的 Transformer 产生的 <code>$\mathbf{X}_{\mathbf{Z}&lt;t}$</code> 的隐含表示。该表示并不依赖于所预测的位置，为了避免这个问题，我们将位置 <code>$z_t$</code> 加入到模型中：</p>

<p><code>$$
p_{\theta}\left(X_{z_{t}}=x | \mathbf{x}_{z_{&lt;t}}\right)=\frac{\exp \left(e(x)^{\top} g_{\theta}\left(\mathbf{x}_{\mathbf{z}&lt;t}, z_{t}\right)\right)}{\sum_{x^{\prime}} \exp \left(e\left(x^{\prime}\right)^{\top} g_{\theta}\left(\mathbf{x}_{\mathbf{z}&lt;t}, z_{t}\right)\right)}
$$</code></p>

<p>对于 <code>$g_{\theta}\left(\mathbf{x}_{\mathbf{z}&lt;t}, z_{t}\right)$</code> 进行建模需要满足如下两个要求：</p>

<ol>
<li>预测 <code>$x_{z_t}$</code> 时，<code>$g_{\theta}\left(\mathbf{x}_{\mathbf{z}&lt;t}, z_{t}\right)$</code> 只能使用位置信息 <code>$z_t$</code> 而不能使用内容信息 <code>$x_{z_t}$</code>。</li>
<li>在预测 <code>$x_{z_t}$</code> 之后的词条时，<code>$g_{\theta}\left(\mathbf{x}_{\mathbf{z}&lt;t}, z_{t}\right)$</code> 又必须包含 <code>$x_{z_t}$</code> 的语义信息。</li>
</ol>

<p>为了解决这个问题，XLNet 提供了两种隐含表示：</p>

<ol>
<li>内容隐含表示 <code>$h_{\theta}\left(\mathbf{x}_{\mathbf{z} \leq t}\right)$</code>，简写为 <code>$h_{z_t}$</code>，它和标准的 Transformer 一样，既编码上下文也编码 <code>$x_{z_t}$</code> 的内容。</li>
<li>查询隐含表示 <code>$g_{\theta}\left(\mathbf{x}_{\mathbf{z}&lt;t}, z_{t}\right)$</code>，简写为 <code>$g_{z_t}$</code>，它仅编码上下文信息 <code>$\mathbf{X}_{\mathbf{Z}&lt;t}$</code> 和位置信息 <code>$z_t$</code>，不编码内容 <code>$x_{z_t}$</code>。</li>
</ol>

<p>模型的整个计算过程如下图所示：</p>

<figure>
  <img data-src="/images/cn/2020-03-28-pre-trained-model-for-nlp/xlnet.png" class="lazyload"/>
  
</figure>

<p>虽然排列语言模型有很多优点，但是由于计算量很大，模型很难进行优化，因此我们通过仅预测一个句子后面的一些词条解决这个问题。将 <code>$\mathbf{z}$</code> 分为两部分：非目标子序列 <code>$\mathbf{z}_{\leq c}$</code> 和目标子序列 <code>$\mathbf{z}_{&gt;c}$</code>，其中 <code>$c$</code> 为切分点。同时会设置一个超参数 <code>$K$</code>，表示仅 <code>$1 / K$</code> 的词条会被预测，有 <code>$|\mathbf{z}| /(|\mathbf{z}|-c) \approx K$</code>。对于未被选择的词条，其查询隐状态无需被计算，从而节省计算时间和资源。</p>

<h3 id="mass-2019-song2019mass">MASS (2019) <sup class="footnote-ref" id="fnref:song2019mass"><a href="#fn:song2019mass">16</a></sup></h3>

<p>MASS 是一个专门针对序列到序列的自然语言任务设计的预训练方法，对于一个给定的原始句子 <code>$x \in \mathcal{X}$</code>，令 <code>$x^{\setminus u:v}$</code> 表示将 <code>$x$</code> 从 <code>$u$</code> 到 <code>$v$</code> 位置进行遮挡处理，<code>$k = v - u + 1$</code> 为被遮挡词条的个数，<code>$x^{u:v}$</code> 为从 <code>$u$</code> 到 <code>$v$</code> 位置被遮挡的部分。MASS 利用被遮挡的序列 <code>$x^{\setminus u:v}$</code> 预测被遮挡的部分 <code>$x^{u:v}$</code>，目标函数的对数似然如下：</p>

<p><code>$$
\begin{aligned}
L(\theta ; \mathcal{X}) &amp;=\frac{1}{|\mathcal{X}|} \Sigma_{x \in \mathcal{X}} \log P\left(x^{u: v} | x^{\setminus u: v} ; \theta\right) \\
&amp;=\frac{1}{|\mathcal{X}|} \Sigma_{x \in \mathcal{X}} \log \prod_{t=u}^{v} P\left(x_{t}^{u: v} | x_{&lt;t}^{u: v}, x^{\setminus u: v} ; \theta\right)
\end{aligned}
$$</code></p>

<p>对于一个具有 8 个词条的序列，<code>$x_3 x_4 x_5 x_6$</code> 被遮挡的示例如下：</p>

<figure>
  <img data-src="/images/cn/2020-03-28-pre-trained-model-for-nlp/mass.png" class="lazyload"/>
  
</figure>

<p>模型仅预测遮挡的部分 <code>$x_3 x_4 x_5 x_6$</code>，对于解码器中位置 <code>$4-6$</code> 利用 <code>$x_3 x_4 x_5$</code> 作为输入，利用特殊遮挡符号 <code>$\left[\mathbb{M}\right]$</code> 作为其他位置的输入。对于不同长度 <code>$k$</code>，MASS 包含了上文中提到的两种预训练模型：</p>

<table>
<thead>
<tr>
<th>长度</th>
<th>概率</th>
<th>模型</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>$k=1$</code></td>
<td><code>$P\left(x^{u} \mid x^{\setminus u} ; \theta\right)$</code></td>
<td>masked LM in BERT</td>
</tr>

<tr>
<td><code>$k=m$</code></td>
<td><code>$P\left(x^{1:m} \mid x^{\setminus 1:m} ; \theta\right)$</code></td>
<td>masked LM in GPT</td>
</tr>

<tr>
<td><code>$k \in \left(1, m\right)$</code></td>
<td><code>$P\left(x^{u:v} \mid x^{\setminus u:v} ; \theta\right)$</code></td>
<td>两种之间</td>
</tr>
</tbody>
</table>

<p>对于不同 <code>$k$</code> 值，实验发现当 <code>$k$</code> 处于 <code>$m$</code> 的 <code>$50\%$</code> 至 <code>$70\%$</code> 之间时下游任务性能最优。</p>

<figure>
  <img data-src="/images/cn/2020-03-28-pre-trained-model-for-nlp/mass-k.png" class="lazyload"/>
  
</figure>

<p>当 <code>$k = 0.5 m$</code> 时，MASS 可以很好地平衡编码器和解码器的预训练。过度地偏向编码器（<code>$k=1$</code>，masked LM in BERT）和过度地偏向解码器（<code>$k=m$</code>，masked LM in GPT）均不能在下游的自然语言生成任务中取得很好的效果。</p>

<h3 id="roberta-2019-liu2019roberta">RoBERTa (2019) <sup class="footnote-ref" id="fnref:liu2019roberta"><a href="#fn:liu2019roberta">18</a></sup></h3>

<p>RoBERTa 主要围绕 BERT 进行了如下改进：</p>

<ol>
<li>模型采用了动态遮罩，不同于原始 BERT 中对语料预先进行遮罩处理，RoBERTa 在 40 轮训练过程中采用了 10 种不同的遮罩。</li>
<li>模型去掉了 NSP 任务，发现可以略微提升下游任务的性能。</li>
<li>模型采用了更大的训练数据和更大的 Batch 大小。</li>
<li>原始 BERT 采用一个 30K 的 BPE 词表，RoBERTa 采用了一个更大的 50K 的词表 <sup class="footnote-ref" id="fnref:radford2019language"><a href="#fn:radford2019language">28</a></sup>。</li>
</ol>

<h3 id="bart-2019-lewis2019bart">BART (2019) <sup class="footnote-ref" id="fnref:lewis2019bart"><a href="#fn:lewis2019bart">20</a></sup></h3>

<p>BART 采用了一个标准的 Seq2Seq Transformer 结构，类似 GPT 将 ReLU 激活函数替换为 GeLUs。对于基线模型，采用了一个 6 层的编码和解码器，对于更大模型采用了 12 层的结构。相比于 BERT 的架构主要有以下两点不同：</p>

<ol>
<li>解码器的每一层叠加了对编码器最后一个隐含层的注意力。</li>
<li>BERT 在预测之前采用了一个前馈的网络，而 BART 没有。</li>
</ol>

<p>BART 采用了最小化破坏后的文档和原始文档之间的重构误差的方式进行预训练。不同于其他的一些去噪自编码器，BART 可以使用任意类型的文档破坏方式。极端情况下，当源文档的所有信息均丢失时，BART 就等价与一个语言模型。BART 中采用的文本破坏方式有：字符遮罩，字符删除，文本填充，句子重排，文档旋转，如下图所示：</p>

<figure>
  <img data-src="/images/cn/2020-03-28-pre-trained-model-for-nlp/bart-transformations.png" class="lazyload"/>
  
</figure>

<h3 id="t5-2019-raffel2019exploring">T5 (2019) <sup class="footnote-ref" id="fnref:raffel2019exploring"><a href="#fn:raffel2019exploring">17</a></sup></h3>

<p>T5（Text-to-Text Transfer Transformer） 提出了一种 text-to-text 的框架，旨在利用相同的模型，损失函数和超参数等对机器翻译，文档摘要，问答和分类（例如：情感分析）等任务进行统一建模。我们甚至可以利用 T5 通过预测一个数字的文本表示而不是数字本身来建模一个回归任务。模型及其输入输出如下图所示：</p>

<figure>
  <img data-src="/images/cn/2020-03-28-pre-trained-model-for-nlp/t5-text-to-text-framework.gif" class="lazyload"/>
  
</figure>

<p>Google 的这项研究并不是提出一种新的方法，而是从全面的视角来概述当前 NLP 领域迁移学习的发展现状。T5 还公开了一个名为 C4（Colossal Clean Crawled Corpus）的数据集，该数据集是一个比 Wikipedia 大两个数量级的 Common Crawl 的清洗后版本的数据。更多模型的细节请参见源论文和 Google 的 <a href="https://ai.googleblog.com/2020/02/exploring-transfer-learning-with-t5.html" rel="noreferrer" target="_blank">官方博客</a>。</p>

<h3 id="ernie-baidu-2019-sun2019ernie-sun2019ernie2">ERNIE (Baidu, 2019) <sup class="footnote-ref" id="fnref:sun2019ernie"><a href="#fn:sun2019ernie">29</a></sup> <sup class="footnote-ref" id="fnref:sun2019ernie2"><a href="#fn:sun2019ernie2">30</a></sup></h3>

<p>ERNIE 1.0 <sup class="footnote-ref" id="fnref:sun2019ernie"><a href="#fn:sun2019ernie">29</a></sup> 通过建模海量数据中的词、实体及实体关系，学习真实世界的语义知识。相较于 BERT 学习原始语言信号，ERNIE 直接对先验语义知识单元进行建模，增强了模型语义表示能力。例如：</p>

<p><code>BERT ：哈 [mask] 滨是 [mask] 龙江的省会，[mask] 际冰 [mask] 文化名城。</code><br />
<code>ERNIE：[mask] [mask] [mask] 是黑龙江的省会，国际 [mask] [mask] 文化名城。</code></p>

<p>在 BERT 模型中，我们通过『哈』与『滨』的局部共现，即可判断出『尔』字，模型没有学习与『哈尔滨』相关的任何知识。而 ERNIE 通过学习词与实体的表达，使模型能够建模出『哈尔滨』与『黑龙江』的关系，学到『哈尔滨』是 『黑龙江』的省会以及『哈尔滨』是个冰雪城市。</p>

<p>训练数据方面，除百科类、资讯类中文语料外，ERNIE 还引入了论坛对话类数据，利用 DLM（Dialogue Language Model）建模 Query-Response 对话结构，将对话 Pair 对作为输入，引入 Dialogue Embedding 标识对话的角色，利用 Dialogue Response Loss 学习对话的隐式关系，进一步提升模型的语义表示能力。</p>

<p>ERNIE 2.0 <sup class="footnote-ref" id="fnref:sun2019ernie2"><a href="#fn:sun2019ernie2">30</a></sup> 是基于持续学习的语义理解预训练框架，使用多任务学习增量式构建预训练任务。ERNIE 2.0 中，新构建的预训练任务类型可以无缝的加入训练框架，持续的进行语义理解学习。 通过新增的实体预测、句子因果关系判断、文章句子结构重建等语义任务，ERNIE 2.0 语义理解预训练模型从训练数据中获取了词法、句法、语义等多个维度的自然语言信息，极大地增强了通用语义表示能力。</p>

<figure>
  <img data-src="/images/cn/2020-03-28-pre-trained-model-for-nlp/ernie-2-framework.png" class="lazyload"/>
  
</figure>

<h3 id="state-of-art">State-of-Art</h3>

<p>NLP 任务的 State-of-Art 模型详见：</p>

<ul>
<li><a href="https://gluebenchmark.com/leaderboard" rel="noreferrer" target="_blank">GLUE Leaderboard</a></li>
<li><a href="https://super.gluebenchmark.com/leaderboard" rel="noreferrer" target="_blank">SuperGLUE Leaderboard</a></li>
<li><a href="https://rajpurkar.github.io/SQuAD-explorer/" rel="noreferrer" target="_blank">SQuAD</a></li>
<li><a href="https://nlpprogress.com/" rel="noreferrer" target="_blank">NLP-progress</a></li>
<li><a href="https://www.cluebenchmarks.com/" rel="noreferrer" target="_blank">中文任务基准测评</a></li>
</ul>



  


<script src="/js/load-photoswipe.js"></script>


<link rel="stylesheet" href='//cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.3/photoswipe.min.css'/>
<link rel="stylesheet" href='//cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.3/default-skin/default-skin.min.css'/>
<script src='//cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.3/photoswipe.min.js'></script>
<script src='//cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.3/photoswipe-ui-default.min.js'></script>


<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>

<div class="footnotes">

<hr />

<ol>
<li id="fn:qiu2020pre">Qiu, X., Sun, T., Xu, Y., Shao, Y., Dai, N., &amp; Huang, X. (2020). Pre-trained Models for Natural Language Processing: A Survey. <em>ArXiv:2003.08271 [Cs]</em>. <a href="http://arxiv.org/abs/2003.08271" rel="noreferrer" target="_blank">http://arxiv.org/abs/2003.08271</a>
 <a class="footnote-return" href="#fnref:qiu2020pre">↩</a></li>
<li id="fn:mikolov2013distributed">Mikolov, T., Sutskever, I., Chen, K., Corrado, G. S., &amp; Dean, J. (2013). Distributed representations of words and phrases and their compositionality. In <em>Advances in neural information processing systems</em> (pp. 3111-3119).
 <a class="footnote-return" href="#fnref:mikolov2013distributed">↩</a></li>
<li id="fn:pennington2014glove">Pennington, J., Socher, R., &amp; Manning, C. D. (2014, October). Glove: Global vectors for word representation. In <em>Proceedings of the 2014 conference on empirical methods in natural language processing (EMNLP)</em> (pp. 1532-1543).
 <a class="footnote-return" href="#fnref:pennington2014glove">↩</a></li>
<li id="fn:mccann2017learned">McCann, B., Bradbury, J., Xiong, C., &amp; Socher, R. (2017). Learned in translation: Contextualized word vectors. In <em>Advances in Neural Information Processing Systems</em> (pp. 6294-6305).
 <a class="footnote-return" href="#fnref:mccann2017learned">↩</a></li>
<li id="fn:peters2018deep">Peters, M. E., Neumann, M., Iyyer, M., Gardner, M., Clark, C., Lee, K., &amp; Zettlemoyer, L. (2018). Deep contextualized word representations. <em>arXiv preprint arXiv:1802.05365.</em>
 <a class="footnote-return" href="#fnref:peters2018deep">↩</a></li>
<li id="fn:radford2018improving">Radford, A., Narasimhan, K., Salimans, T., &amp; Sutskever, I. (2018). Improving language understanding by generative pre-training. <em>URL <a href="https://openai.com/blog/language-unsupervised/" rel="noreferrer" target="_blank">https://openai.com/blog/language-unsupervised/</a></em>.
 <a class="footnote-return" href="#fnref:radford2018improving">↩</a></li>
<li id="fn:devlin2018bert">Devlin, J., Chang, M. W., Lee, K., &amp; Toutanova, K. (2018). Bert: Pre-training of deep bidirectional transformers for language understanding. <em>arXiv preprint arXiv:1810.04805.</em>
 <a class="footnote-return" href="#fnref:devlin2018bert">↩</a></li>
<li id="fn:kim2014convolutional">Kim, Y. (2014). Convolutional Neural Networks for Sentence Classification. In <em>Proceedings of the 2014 Conference on Empirical Methods in Natural Language Processing (EMNLP)</em> (pp. 1746-1751).
 <a class="footnote-return" href="#fnref:kim2014convolutional">↩</a></li>
<li id="fn:hochreiter1997long">Hochreiter, S., &amp; Schmidhuber, J. (1997). Long short-term memory. <em>Neural computation</em>, 9(8), 1735-1780.
 <a class="footnote-return" href="#fnref:hochreiter1997long">↩</a></li>
<li id="fn:chung2014empirical">Chung, J., Gulcehre, C., Cho, K., &amp; Bengio, Y. (2014). Empirical evaluation of gated recurrent neural networks on sequence modeling. <em>arXiv preprint arXiv:1412.3555.</em>
 <a class="footnote-return" href="#fnref:chung2014empirical">↩</a></li>
<li id="fn:socher2013recursive">Socher, R., Perelygin, A., Wu, J., Chuang, J., Manning, C. D., Ng, A. Y., &amp; Potts, C. (2013). Recursive deep models for semantic compositionality over a sentiment treebank. In <em>Proceedings of the 2013 conference on empirical methods in natural language processing</em> (pp. 1631-1642).
 <a class="footnote-return" href="#fnref:socher2013recursive">↩</a></li>
<li id="fn:tai2015improved">Tai, K. S., Socher, R., &amp; Manning, C. D. (2015). Improved Semantic Representations From Tree-Structured Long Short-Term Memory Networks. In <em>Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference on Natural Language Processing (Volume 1: Long Papers)</em> (pp. 1556-1566).
 <a class="footnote-return" href="#fnref:tai2015improved">↩</a></li>
<li id="fn:marcheggiani2018exploiting">Marcheggiani, D., Bastings, J., &amp; Titov, I. (2018). Exploiting Semantics in Neural Machine Translation with Graph Convolutional Networks. In <em>Proceedings of the 2018 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies, Volume 2 (Short Papers)</em> (pp. 486-492).
 <a class="footnote-return" href="#fnref:marcheggiani2018exploiting">↩</a></li>
<li id="fn:vaswani2017attention">Vaswani, A., Shazeer, N., Parmar, N., Uszkoreit, J., Jones, L., Gomez, A. N., &hellip; &amp; Polosukhin, I. (2017). Attention is all you need. In <em>Advances in neural information processing systems</em> (pp. 5998-6008).
 <a class="footnote-return" href="#fnref:vaswani2017attention">↩</a></li>
<li id="fn:devlin2019bert">Devlin, J., Chang, M. W., Lee, K., &amp; Toutanova, K. (2019). BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding. In <em>Proceedings of the 2019 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies, Volume 1 (Long and Short Papers)</em> (pp. 4171-4186).
 <a class="footnote-return" href="#fnref:devlin2019bert">↩</a></li>
<li id="fn:song2019mass">Song, K., Tan, X., Qin, T., Lu, J., &amp; Liu, T. Y. (2019). MASS: Masked Sequence to Sequence Pre-training for Language Generation. In <em>International Conference on Machine Learning</em> (pp. 5926-5936).
 <a class="footnote-return" href="#fnref:song2019mass">↩</a></li>
<li id="fn:raffel2019exploring">Raffel, C., Shazeer, N., Roberts, A., Lee, K., Narang, S., Matena, M., &hellip; &amp; Liu, P. J. (2019). Exploring the limits of transfer learning with a unified text-to-text transformer. <em>arXiv preprint arXiv:1910.1068</em>
 <a class="footnote-return" href="#fnref:raffel2019exploring">↩</a></li>
<li id="fn:liu2019roberta">Liu, Y., Ott, M., Goyal, N., Du, J., Joshi, M., Chen, D., &hellip; &amp; Stoyanov, V. (2019). Roberta: A robustly optimized bert pretraining approach. <em>arXiv preprint arXiv:1907.11692.</em>
 <a class="footnote-return" href="#fnref:liu2019roberta">↩</a></li>
<li id="fn:yang2019xlnet">Yang, Z., Dai, Z., Yang, Y., Carbonell, J., Salakhutdinov, R. R., &amp; Le, Q. V. (2019). Xlnet: Generalized autoregressive pretraining for language understanding. In <em>Advances in neural information processing systems</em> (pp. 5754-5764).
 <a class="footnote-return" href="#fnref:yang2019xlnet">↩</a></li>
<li id="fn:lewis2019bart">Lewis, M., Liu, Y., Goyal, N., Ghazvininejad, M., Mohamed, A., Levy, O., &hellip; &amp; Zettlemoyer, L. (2019). Bart: Denoising sequence-to-sequence pre-training for natural language generation, translation, and comprehension. <em>arXiv preprint arXiv:1910.13461.</em>
 <a class="footnote-return" href="#fnref:lewis2019bart">↩</a></li>
<li id="fn:saunshi2019theoretical">Saunshi, N., Plevrakis, O., Arora, S., Khodak, M., &amp; Khandeparkar, H. (2019). A Theoretical Analysis of Contrastive Unsupervised Representation Learning. In <em>International Conference on Machine Learning</em> (pp. 5628-5637).
 <a class="footnote-return" href="#fnref:saunshi2019theoretical">↩</a></li>
<li id="fn:tenney2019bert">Tenney, I., Das, D., &amp; Pavlick, E. (2019). BERT Rediscovers the Classical NLP Pipeline. In <em>Proceedings of the 57th Annual Meeting of the Association for Computational Linguistics</em> (pp. 4593-4601).
 <a class="footnote-return" href="#fnref:tenney2019bert">↩</a></li>
<li id="fn:elmo">图片来源：<a href="http://www.realworldnlpbook.com/blog/improving-sentiment-analyzer-using-elmo.html" rel="noreferrer" target="_blank">http://www.realworldnlpbook.com/blog/improving-sentiment-analyzer-using-elmo.html</a>
 <a class="footnote-return" href="#fnref:elmo">↩</a></li>
<li id="fn:wu2016google">Wu, Y., Schuster, M., Chen, Z., Le, Q. V., Norouzi, M., Macherey, W., &hellip; &amp; Klingner, J. (2016). Google&rsquo;s neural machine translation system: Bridging the gap between human and machine translation. <em>arXiv preprint arXiv:1609.08144.</em>
 <a class="footnote-return" href="#fnref:wu2016google">↩</a></li>
<li id="fn:dong2019unified">Dong, L., Yang, N., Wang, W., Wei, F., Liu, X., Wang, Y., &hellip; &amp; Hon, H. W. (2019). Unified language model pre-training for natural language understanding and generation. In <em>Advances in Neural Information Processing Systems</em> (pp. 13042-13054).
 <a class="footnote-return" href="#fnref:dong2019unified">↩</a></li>
<li id="fn:dai2019transformer">Dai, Z., Yang, Z., Yang, Y., Carbonell, J. G., Le, Q., &amp; Salakhutdinov, R. (2019, July). Transformer-XL: Attentive Language Models beyond a Fixed-Length Context. In <em>Proceedings of the 57th Annual Meeting of the Association for Computational Linguistics</em> (pp. 2978-2988).
 <a class="footnote-return" href="#fnref:dai2019transformer">↩</a></li>
<li id="fn:airfou2019character">Al-Rfou, R., Choe, D., Constant, N., Guo, M., &amp; Jones, L. (2019). Character-level language modeling with deeper self-attention. In <em>Proceedings of the AAAI Conference on Artificial Intelligence</em> (Vol. 33, pp. 3159-3166).
 <a class="footnote-return" href="#fnref:airfou2019character">↩</a></li>
<li id="fn:radford2019language">Radford, A., Wu, J., Child, R., Luan, D., Amodei, D., &amp; Sutskever, I. (2019). Language models are unsupervised multitask learners. <em>URL <a href="https://openai.com/blog/better-language-models/" rel="noreferrer" target="_blank">https://openai.com/blog/better-language-models/</a></em>.
 <a class="footnote-return" href="#fnref:radford2019language">↩</a></li>
<li id="fn:sun2019ernie">Sun, Y., Wang, S., Li, Y., Feng, S., Chen, X., Zhang, H., &hellip; &amp; Wu, H. (2019). Ernie: Enhanced representation through knowledge integration. <em>arXiv preprint arXiv:1904.09223.</em>
 <a class="footnote-return" href="#fnref:sun2019ernie">↩</a></li>
<li id="fn:sun2019ernie2">Sun, Y., Wang, S., Li, Y., Feng, S., Tian, H., Wu, H., &amp; Wang, H. (2019). Ernie 2.0: A continual pre-training framework for language understanding. <em>arXiv preprint arXiv:1907.12412.</em>
 <a class="footnote-return" href="#fnref:sun2019ernie2">↩</a></li>
</ol>
</div>



<link rel="stylesheet" href="/css/donate.css" />


<div class="donate">
  <div class="donate-header"></div>
  <div class="donate-slug" id="donate-slug">pre-trained-model-for-nlp</div>
  <button class="donate-button">赞 赏</button>
  <div class="donate-footer">「真诚赞赏，手留余香」</div>
</div>
<div class="donate-modal-wrapper">
  <div class="donate-modal">
    <div class="donate-box">
      <div class="donate-box-content">
        <div class="donate-box-content-inner">
          <div class="donate-box-header">「真诚赞赏，手留余香」</div>
          <div class="donate-box-body">
            <div class="donate-box-money">
              <button class="donate-box-money-button donate-box-money-button-unchecked" id="donate-box-money-button-2" data-v="2" data-unchecked="￥ 2" data-checked="2 元">￥ 2</button>
              <button class="donate-box-money-button donate-box-money-button-unchecked" id="donate-box-money-button-5" data-v="5" data-unchecked="￥ 5" data-checked="5 元">￥ 5</button>
              <button class="donate-box-money-button donate-box-money-button-unchecked" id="donate-box-money-button-10" data-v="10" data-unchecked="￥ 10" data-checked="10 元">￥ 10</button>
              <button class="donate-box-money-button donate-box-money-button-unchecked" id="donate-box-money-button-50" data-v="50" data-unchecked="￥ 50" data-checked="50 元">￥ 50</button>
              <button class="donate-box-money-button donate-box-money-button-unchecked" id="donate-box-money-button-100" data-v="100" data-unchecked="￥ 100" data-checked="100 元">￥ 100</button>
              <button class="donate-box-money-button donate-box-money-button-unchecked" id="donate-box-money-button-custom" data-v="custom" data-unchecked="任意金额" data-checked="任意金额">任意金额</button>
            </div>
            <div class="donate-box-pay">
              <img class="donate-box-pay-qrcode" id="donate-box-pay-qrcode" src=""/>
            </div>
          </div>
          <div class="donate-box-footer">
            <div class="donate-box-pay-method donate-box-pay-method-checked" data-v="wechat-pay">
              <img class="donate-box-pay-method-image" id="donate-box-pay-method-image-wechat-pay" src=""/>
            </div>
            <div class="donate-box-pay-method" data-v="alipay">
              <img class="donate-box-pay-method-image"  id="donate-box-pay-method-image-alipay" src=""/>
            </div>
          </div>
        </div>
      </div>
    </div>
    <button type="button" class="donate-box-close-button">
      <svg class="donate-box-close-button-icon" fill="#fff" viewBox="0 0 24 24" width="24" height="24"><path d="M13.486 12l5.208-5.207a1.048 1.048 0 0 0-.006-1.483 1.046 1.046 0 0 0-1.482-.005L12 10.514 6.793 5.305a1.048 1.048 0 0 0-1.483.005 1.046 1.046 0 0 0-.005 1.483L10.514 12l-5.208 5.207a1.048 1.048 0 0 0 .006 1.483 1.046 1.046 0 0 0 1.482.005L12 13.486l5.207 5.208a1.048 1.048 0 0 0 1.483-.006 1.046 1.046 0 0 0 .005-1.482L13.486 12z" fill-rule="evenodd"></path></svg>
    </button>
  </div>
</div>

<script type="text/javascript" src="/js/donate.js"></script>
</script>


  <footer>
  
<nav class="post-nav">
  <span class="nav-prev">&larr; <a href="/user_blogdown/cn/2019/11/user-privileges-of-2b-products/">ToB 产品用户权限 (User Privileges of ToB Products)</a></span>
  <span class="nav-next"><a href="/user_blogdown/cn/2020/04/graph-embedding-and-gnn/">图嵌入 (Graph Embedding) 和图神经网络 (Graph Neural Network)</a> &rarr;</span>
</nav>
<script type="text/javascript">
document.addEventListener('keyup', function(e) {
  if (e.target.nodeName.toUpperCase() != 'BODY') return;
  var url = false;
  if (e.which == 37) {  
    
    url = '\/user_blogdown\/cn\/2019\/11\/user-privileges-of-2b-products\/';
    
  } else if (e.which == 39) {  
    
    url = '\/user_blogdown\/cn\/2020\/04\/graph-embedding-and-gnn\/';
    
  }
  if (url) window.location = url;
});
</script>




<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-2608165017777396"
     data-ad-slot="1261604535"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>





<section class="comments">
  <div id="disqus_thread"></div>
  <script>
  var disqus_config = function () {
  
    this.page.url = "https:\/\/zeqiang.fun" + location.pathname;
  
  };
  (function() {
    var inIFrame = function() {
      var iframe = true;
      try { iframe = window.self !== window.top; } catch (e) {}
      return iframe;
    };
    if (inIFrame()) return;
    var disqus_js = '//Zeqiang.disqus.com/embed.js';
    var d = document, s = d.createElement('script');
    s.src = disqus_js; s.async = true;
    s.setAttribute('data-timestamp', +new Date());
    var t = d.getElementById('disqus_thread');
    var b = false, l = function(scroll) {
      if (b) return;
      (d.head || d.body).appendChild(s); b = true;
      if (scroll) t.scrollIntoView();
    }
    s.onerror = function(e) {
      if (sessionStorage.getItem('failure-note')) return;
      t.innerText = 'Sorry, but you cannot make comments because Disqus failed to load for some reason. It is known to be blocked in China. If you are sure it is not blocked in your region, please refresh the page. 中国大陆地区读者需要翻墙才能发表评论。';
      sessionStorage.setItem('failure-note', true);
    };
    
    if (location.hash.match(/^#comment-[0-9]+$/)) return l(true);
    var c = function() {
      if (b) return;
      var rect = t.getBoundingClientRect();
      if (rect.top < window.innerHeight && rect.bottom >= 0) l();
    };
    window.addEventListener('load', c);
    d.addEventListener('scroll', c);
  })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</section>




<script async src="/js/fix-toc.js"></script>
<script async src="/js/center-img.js"></script>
<script async src="/js/right-quote.js"></script>
<script async src="/js/fix-footnote.js"></script>
<script async src="/js/external-link.js"></script>
<script async src="/js/alt-title.js"></script>
<script src="/js/no-highlight.js"></script>
<script src="/js/math-code.js"></script>


<script>
window.MathJax = {
  loader: {
    load: ['[tex]/boldsymbol']
  },
  tex: {
    tags: "all",
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$']],
    processEscapes: true,
    processEnvironments: true,
    packages: {
      '[+]': ['boldsymbol']
    }
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.0/es5/tex-chtml.js" crossorigin></script>







<script async src="/js/load-typekit.js"></script>

<script src="//cdnjs.cloudflare.com/ajax/libs/lazysizes/5.3.2/lazysizes.min.js"></script>

<script src="//cdn.jsdelivr.net/npm/vanilla-back-to-top@latest/dist/vanilla-back-to-top.min.js"></script>
<script>
addBackToTop({
  diameter: 48
})
</script>



  <hr>
  <div class="copyright no-border-bottom">
    <div class="copyright-author-year">
      <span>&copy; 2017-2021 Leo Van</span>
    </div>
    <div class="copyright-links">
      <a href="https://github.com/leovan" rel="noreferrer" target="_blank">Github</a>
      <span> · </span>
      <a href="https://orcid.org/0000-0002-9556-7821" rel="noreferrer" target="_blank">ORCID</a>
      <span> · </span>
      <span>I am Mr. Black.</span>
    </div>
  </div>
  </footer>
  </article>
  </body>
</html>


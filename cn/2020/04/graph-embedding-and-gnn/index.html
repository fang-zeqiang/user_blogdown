<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">

        <title>图嵌入 (Graph Embedding) 和图神经网络 (Graph Neural Network) - Zeqiang Fang | 方泽强</title>

    <meta name="referrer" content="no-referrer">
    
    <meta property="og:title" content="图嵌入 (Graph Embedding) 和图神经网络 (Graph Neural Network) - Zeqiang Fang | 方泽强">
    <meta name="description" property="og:description" content="图（Graph / Network）数据类型可以自然地表达物体和物体之间的联系，在我们的日常生活与工作中无处不在。例如：微信和新浪微博等构成了人">
    <meta property="og:type" content="article">
    <meta property="og:site_name" content="Zeqiang Fang | 方泽强">
    <meta property="og:url" content="https://leovan.me/cn/2020/04/graph-embedding-and-gnn/">

    
    
    
    
    <meta name="author" property="article:author" content="范叶亮">
    
    
    
    <meta name="date" property="article:published_time" content="2020-04-11" scheme="YYYY-MM-DD">
    
    
    <meta name="date" property="article:modified_time" content="2020-04-11" scheme="YYYY-MM-DD">
    

    
    <meta name="keywords" property="article:tag" content ="图嵌入,网络嵌入,图表示学习,网络表示学习,Graph Embedding,Random Walk,DeepWalk,node2vec,APP,Matrix Fractorization,GraRep,HOPE,Meta Paths,metapath2vec,HIN2Vec,SDNE,DNGR,LINE,图神经网络,Graph Neural Networks,GNN,Graph Convolutional Networks,GCN,ChebNet,DCNN,GraphSAGE,Graph Recurrent Networks,GGNN,Tree LSTM,Graph LSTM,Graph Attention Networks,GAT">
    
    
    <meta name="theme-color" content="#0d0d0d">
    
    <link rel="icon" type="image/png" sizes="16x16" href="/images/web/favicon-16x16.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/images/web/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="48x48" href="/images/web/favicon-48x48.png">
    <link rel="icon" type="image/png" sizes="62x62" href="/images/web/favicon-62x62.png">
    <link rel="icon" type="image/png" sizes="192x192" href="/images/web/favicon-192x192.png">
    <link rel="apple-touch-icon" size="192x192" href="/images/web/icon-192x192.png">
    <link rel="manifest" href="/manifest.json">
        
    

    

    <script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https://leovan.me/cn"
        },
        "name": "图嵌入 (Graph Embedding) 和图神经网络 (Graph Neural Network)",
        "headline": "图嵌入 (Graph Embedding) 和图神经网络 (Graph Neural Network)",
        "description" : "图（Graph / Network）数据类型可以自然地表达物体和物体之间的联系，在我们的日常生活与工作中无处不在。例如：微信和新浪微博等构成了人",
        "genre": [
            "深度学习", "表示学习"
        ],
        "datePublished": "2020-04-11",
        "dateModified": "2020-04-11",
        "wordCount": "10733",
        "keywords": [
            "图嵌入", "网络嵌入", "图表示学习", "网络表示学习", "Graph Embedding", "Random Walk", "DeepWalk", "node2vec", "APP", "Matrix Fractorization", "GraRep", "HOPE", "Meta Paths", "metapath2vec", "HIN2Vec", "SDNE", "DNGR", "LINE", "图神经网络", "Graph Neural Networks", "GNN", "Graph Convolutional Networks", "GCN", "ChebNet", "DCNN", "GraphSAGE", "Graph Recurrent Networks", "GGNN", "Tree LSTM", "Graph LSTM", "Graph Attention Networks", "GAT"
        ],
        "image": [
            "https://leovan.me/images/cn/2020-04-11-graph-embedding-and-gnn/graph-embedding-vs-graph-neural-networks.png", "https://leovan.me/images/cn/2020-04-11-graph-embedding-and-gnn/gnn-graph-types.png", "https://leovan.me/images/cn/2020-04-11-graph-embedding-and-gnn/gnn-training-methods.png", "https://leovan.me/images/cn/2020-04-11-graph-embedding-and-gnn/gnn-propagation-steps.png"
        ],
        "author": {
            "@type": "Person",
            "name": "范叶亮"
        },
        "publisher": {
            "@type": "Organization",
            "name": "范叶亮",
            "logo": {
                "@type": "ImageObject",
                "url": "https://leovan.me/images/web/publisher-logo.png"
            }
        },
        "url": "https://leovan.me/cn/2020/04/graph-embedding-and-gnn/"
    }
    </script>
    

    <script src='//cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js'></script>
<script src='//cdnjs.cloudflare.com/ajax/libs/js-cookie/2.2.1/js.cookie.min.js'></script>

<link rel="stylesheet" type="text/css" href="//cdnjs.cloudflare.com/ajax/libs/MaterialDesign-Webfont/6.5.95/css/materialdesignicons.min.css">





<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<link rel="stylesheet" type="text/css" href="/css/fonts.css" />
<link rel="stylesheet" type="text/css" href="/css/style.css">
<link rel="stylesheet" type="text/css" href="/css/light.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" id="dark-mode-style" disabled="disabled">
<link rel="stylesheet" type="text/css" href="/css/icons.css">
<link rel="stylesheet" type="text/css" href="/css/print.css">

  </head>

  
  <body class="cn">
    <header class="masthead">
      

<div class="logo"></div>
<p class="slogan">优雅永不过时</p>
      <nav class="menu">
  <ul>
  
  
  
    
  
  
    <li><a href="/">首页</a></li>
  
    <li><a href="/cn/">博客</a></li>
  
    <li><a href="/categories/">分类</a></li>
  
    <li class="menu-separator"><span>&nbsp;</span></li>
  
    <li><a href="/cn/about/">关于</a></li>
  
    <li><a href="/cn/resume/">简历</a></li>
  
  


<li class="menu-separator"><span>&nbsp;</span></li>

<li><a href="/cn/index.xml" target="_blank" type="application/rss+xml" title="RSS feed">订阅</a></li>

<li><a href="https://github.com/fang-zeqiang/fang-zeqiang.github.io/blob/master/LICENSE" target="_blank" title="Attribution-NonCommercial-ShareAlike 4.0 International">版权</a></li>


  <li class="light-dark-mode no-border-bottom"><a id="light-dark-mode-action"><span id="light-dark-mode-icon" class="mdi mdi-weather-night"></span></a></li>
  </ul>
</nav>

      <script src="/js/toggle-theme.js"></script>
    </header>

    <article class="main">
      <header class="title">
      
<h1>图嵌入 (Graph Embedding) 和图神经网络 (Graph Neural Network)</h1>







<h3>范叶亮 / 
2020-04-11</h3>



<h3 class="post-meta">


<strong>分类: </strong>
<a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0">深度学习</a>, <a href="/categories/%E8%A1%A8%E7%A4%BA%E5%AD%A6%E4%B9%A0">表示学习</a>




/




<strong>标签: </strong>
<span>图嵌入</span>, <span>网络嵌入</span>, <span>图表示学习</span>, <span>网络表示学习</span>, <span>Graph Embedding</span>, <span>Random Walk</span>, <span>DeepWalk</span>, <span>node2vec</span>, <span>APP</span>, <span>Matrix Fractorization</span>, <span>GraRep</span>, <span>HOPE</span>, <span>Meta Paths</span>, <span>metapath2vec</span>, <span>HIN2Vec</span>, <span>SDNE</span>, <span>DNGR</span>, <span>LINE</span>, <span>图神经网络</span>, <span>Graph Neural Networks</span>, <span>GNN</span>, <span>Graph Convolutional Networks</span>, <span>GCN</span>, <span>ChebNet</span>, <span>DCNN</span>, <span>GraphSAGE</span>, <span>Graph Recurrent Networks</span>, <span>GGNN</span>, <span>Tree LSTM</span>, <span>Graph LSTM</span>, <span>Graph Attention Networks</span>, <span>GAT</span>




/


<strong>字数: </strong>
10733
</h3>



<hr>


      </header>



<div class="toc-depth-2" ><nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#图嵌入">图嵌入</a>
<ul>
<li><a href="#random-walk">Random Walk</a>
<ul>
<li><a href="#deepwalk">DeepWalk</a></li>
<li><a href="#node2vec">node2vec</a></li>
<li><a href="#app">APP</a></li>
</ul></li>
<li><a href="#matrix-fractorization">Matrix Fractorization</a>
<ul>
<li><a href="#grarep">GraRep</a></li>
<li><a href="#hope">HOPE</a></li>
</ul></li>
<li><a href="#meta-paths">Meta Paths</a>
<ul>
<li><a href="#matapath2vec">matapath2vec</a></li>
<li><a href="#hin2vec">HIN2Vec</a></li>
</ul></li>
<li><a href="#deep-learning">Deep Learning</a>
<ul>
<li><a href="#sdne">SDNE</a></li>
<li><a href="#dngr">DNGR</a></li>
</ul></li>
<li><a href="#others">Others</a>
<ul>
<li><a href="#line">LINE</a></li>
</ul></li>
</ul></li>
<li><a href="#图神经网络">图神经网络</a>
<ul>
<li><a href="#graph-neural-networks">Graph Neural Networks</a></li>
<li><a href="#graph-convolutional-networks">Graph Convolutional Networks</a>
<ul>
<li><a href="#基于频谱的方法-spectral-methods">基于频谱的方法（Spectral Methods）</a></li>
<li><a href="#基于空间的方法-spatial-methods">基于空间的方法（Spatial Methods）</a></li>
</ul></li>
<li><a href="#graph-recurrent-networks">Graph Recurrent Networks</a></li>
<li><a href="#graph-attention-networks">Graph Attention Networks</a></li>
<li><a href="#应用">应用</a></li>
</ul></li>
<li><a href="#开放资源">开放资源</a>
<ul>
<li><a href="#开源实现">开源实现</a></li>
<li><a href="#论文列表和评测">论文列表和评测</a></li>
</ul></li>
</ul></li>
</ul>
</nav></div> 




<p>图（Graph / Network）数据类型可以自然地表达物体和物体之间的联系，在我们的日常生活与工作中无处不在。例如：微信和新浪微博等构成了人与人之间的社交网络；互联网上成千上万个页面构成了网页链接网络；国家城市间的运输交通构成了物流网络。</p>

<figure>
  <img data-src="/images/cn/2020-04-11-graph-embedding-and-gnn/graph.png" class="lazyload"/>
  <figcaption><p class="figcaption">图片来源：<a href="https://www.allthingsdistributed.com/2019/12/power-of-relationships.html" rel="noreferrer" target="_blank">The power of relationships in data</a></p></figcaption>
</figure>

<p>通常定义一个图 <code>$G = \left(V, E\right)$</code>，其中 <code>$V$</code> 为<strong>顶点（Vertices）</strong>集合，<code>$E$</code> 为<strong>边（Edges）</strong>集合。对于一条边 <code>$e = u, v$</code> 包含两个<strong>端点（Endpoints）</strong> <code>$u$</code> 和 <code>$v$</code>，同时 <code>$u$</code> 可以称为 <code>$v$</code> 的<strong>邻居（Neighbor）</strong>。当所有的边为有向边时，图称之为<strong>有向（Directed）</strong>图，当所有边为无向边时，图称之为<strong>无向（Undirected）</strong>图。对于一个顶点 <code>$v$</code>，令 <code>$d \left(v\right)$</code> 表示连接的边的数量，称之为<strong>度（Degree）</strong>。对于一个图 <code>$G = \left(V, E\right)$</code>，其<strong>邻接矩阵（Adjacency Matrix）</strong> <code>$A \in \mathbb{A}^{|V| \times |V|}$</code> 定义为：</p>

<p><code>$$
A_{i j}=\left\{\begin{array}{ll}
1 &amp; \text { if }\left\{v_{i}, v_{j}\right\} \in E \text { and } i \neq j \\
0 &amp; \text { otherwise }
\end{array}\right.
$$</code></p>

<p>作为一个典型的非欧式数据，对于图数据的分析主要集中在节点分类，链接预测和聚类等。对于图数据而言，<strong>图嵌入（Graph / Network Embedding）</strong>和<strong>图神经网络（Graph Neural Networks, GNN）</strong>是两个类似的研究领域。图嵌入旨在将图的节点表示成一个低维向量空间，同时保留网络的拓扑结构和节点信息，以便在后续的图分析任务中可以直接使用现有的机器学习算法。一些基于深度学习的图嵌入同时也属于图神经网络，例如一些基于图自编码器和利用无监督学习的图卷积神经网络等。下图描述了图嵌入和图神经网络之间的差异：</p>

<figure>
  <img data-src="/images/cn/2020-04-11-graph-embedding-and-gnn/graph-embedding-vs-graph-neural-networks.png" class="lazyload"/>
  
</figure>

<div class="blockquote" style='border-left: 4px solid #F66E40;'>本文中<strong>图嵌入</strong>和<strong>网络表示学习</strong>均表示 Graph / Network Embedding。</div>

<h2 id="图嵌入">图嵌入</h2>

<blockquote>
<p>本节内容主要参考自：<br />
A Comprehensive Survey of Graph Embedding: Problems, Techniques and Applications <sup class="footnote-ref" id="fnref:cai2018comprehensive"><a href="#fn:cai2018comprehensive">1</a></sup><br />
Graph Embedding Techniques, Applications, and Performance: A Survey <sup class="footnote-ref" id="fnref:goyal2018graph"><a href="#fn:goyal2018graph">2</a></sup><br />
Representation Learning on Graphs: Methods and Applications <sup class="footnote-ref" id="fnref:hamilton2017representation"><a href="#fn:hamilton2017representation">3</a></sup></p>
</blockquote>

<p>使用邻接矩阵的网络表示存在计算效率的问题，邻接矩阵 <code>$A$</code> 使用 <code>$|V| \times |V|$</code> 的存储空间表示一个图，随着节点个数的增长，这种表示所需的空间成指数增长。同时，在邻接矩阵中绝大多数是 0，数据的稀疏性使得快速有效的学习方式很难被应用。</p>

<p>网路表示学习是指学习得到网络中节点的低维向量表示，形式化地，网络表示学习的目标是对每个节点 <code>$v \in V$</code> 学习一个实值向量 <code>$R_v \in \mathbb{R}^k$</code>，其中 <code>$k \ll |V|$</code> 表示向量的维度。经典的 Zachary&rsquo;s karate club 网络的嵌入可视化如下图所示：</p>

<figure>
  <img data-src="/images/cn/2020-04-11-graph-embedding-and-gnn/karate-graph-embedding.png" class="lazyload"/>
  
</figure>

<h3 id="random-walk">Random Walk</h3>

<p>基于随机游走的图嵌入通过使得图上一个短距的随机游走中共现的节点具有更相似的表示的方式来优化节点的嵌入。</p>

<h4 id="deepwalk">DeepWalk</h4>

<p>DeepWalk <sup class="footnote-ref" id="fnref:perozzi2014deepwalk"><a href="#fn:perozzi2014deepwalk">4</a></sup> 算法主要包含两个部分：一个随机游走序列生成器和一个更新过程。随机游走序列生成器首先在图 <code>$G$</code> 中均匀地随机抽样一个随机游走 <code>$\mathcal{W}_{v_i}$</code> 的根节点 <code>$v_i$</code>，接着从节点的邻居中均匀地随机抽样一个节点直到达到设定的最大长度 <code>$t$</code>。对于一个生成的以 <code>$v_i$</code> 为中心左右窗口为 <code>$w$</code> 的随机游走序列 <code>$v_{i-w}, \dotsc, v_{i-1}, v_i, v_{i+1}, \dotsc, v_{i+m}$</code>，DeepWalk 利用 SkipGram 算法通过最大化以 <code>$v_i$</code> 为中心，左右 <code>$w$</code> 为窗口的同其他节点共现概率来优化模型：</p>

<p><code>$$
\text{Pr} \left(\left\{v_{i-w}, \dotsc, v_{i+w}\right\} \setminus v_i \mid \Phi \left(v_i\right)\right) = \prod_{j=i-w, j \neq i}^{i+w} \text{Pr} \left(v_j \mid \Phi \left(v_i\right)\right)
$$</code></p>

<p>DeepWalk 和 Word2Vec 的类比如下表所示：</p>

<table>
<thead>
<tr>
<th>模型</th>
<th>目标</th>
<th>输入</th>
<th>输出</th>
</tr>
</thead>

<tbody>
<tr>
<td>Word2Vec</td>
<td>词</td>
<td>句子</td>
<td>词嵌入</td>
</tr>

<tr>
<td>DeepWalk</td>
<td>节点</td>
<td>节点序列</td>
<td>节点嵌入</td>
</tr>
</tbody>
</table>

<h4 id="node2vec">node2vec</h4>

<p>node2vec <sup class="footnote-ref" id="fnref:grover2016node2vec"><a href="#fn:grover2016node2vec">5</a></sup> 通过改变随机游走序列生成的方式进一步扩展了 DeepWalk 算法。DeepWalk 选取随机游走序列中下一个节点的方式是均匀随机分布的，而 node2vec 通过引入两个参数 <code>$p$</code> 和 <code>$q$</code>，将<strong>宽度优先搜索</strong>和<strong>深度优先搜索</strong>引入了随机游走序列的生成过程。 宽度优先搜索注重邻近的节点并刻画了相对局部的一种网络表示， 宽度优先中的节点一般会出现很多次，从而降低刻画中心节点的邻居节点的方差， 深度优先搜索反映了更高层面上的节点之间的同质性。</p>

<figure>
  <img data-src="/images/cn/2020-04-11-graph-embedding-and-gnn/node2vec.png" class="lazyload"/>
  
</figure>

<p>node2vec 中的两个参数 <code>$p$</code> 和 <code>$q$</code> 控制随机游走序列的跳转概率。假设上一步游走的边为 <code>$\left(t, v\right)$</code>， 那么对于节点 <code>$v$</code> 的不同邻居，node2vec 根据 <code>$p$</code> 和 <code>$q$</code> 定义了不同的邻居的跳转概率，<code>$p$</code> 控制跳向上一个节点的邻居的概率，<code>$q$</code> 控制跳向上一个节点的非邻居的概率，具体的未归一的跳转概率值 <code>$\pi_{vx} = \alpha_{pq} \left(t, x\right)$</code> 如下所示：</p>

<p><code>$$
\alpha_{p q}(t, x)=\left\{\begin{array}{cl}
\dfrac{1}{p}, &amp; \text { if } d_{t x}=0 \\
1, &amp; \text { if } d_{t x}=1 \\
\dfrac{1}{q}, &amp; \text { if } d_{t x}=2
\end{array}\right.
$$</code></p>

<p>其中，<code>$d_{tx}$</code> 表示节点 <code>$t$</code> 和 <code>$x$</code> 之间的最短距离。为了获得最优的超参数 <code>$p$</code> 和 <code>$q$</code> 的取值，node2vec 通过半监督形式，利用网格搜索最合适的参数学习节点表示。</p>

<h4 id="app">APP</h4>

<p>之前的基于随机游走的图嵌入方法，例如：DeepWalk，node2vec 等，都无法保留图中的非对称信息。然而非对称性在很多问题，例如：社交网络中的链路预测、电商中的推荐等，中至关重要。在有向图和无向图中，非对称性如下图所示：</p>

<figure>
  <img data-src="/images/cn/2020-04-11-graph-embedding-and-gnn/asymmetric-proximity.png" class="lazyload"/>
  
</figure>

<p>为了保留图的非对称性，对于每个节点 <code>$v$</code> 设置两个不同的角色：源和目标，分别用 <code>$\overrightarrow{s_{v}}$</code> 和 <code>$\overrightarrow{t_{v}}$</code> 表示。对于每个从 <code>$u$</code> 开始以 <code>$v$</code> 结尾的采样序列，利用 <code>$(u, v)$</code> 表示采样的节点对。则利用源节点 <code>$u$</code> 预测目标节点 <code>$v$</code> 的概率如下：</p>

<p><code>$$
p(v | u)=\frac{\exp (\overrightarrow{s_{u}} \cdot \overrightarrow{t_{v}})}{\sum_{n \in V} \exp (\overrightarrow{s_{u}} \cdot \overrightarrow{t_{n}})}
$$</code></p>

<p>通过 Skip-Gram 和负采样对模型进行优化，损失函数如下：</p>

<p><code>$$
\begin{aligned}
\ell &amp;= \log \sigma(\overrightarrow{s_{u}} \cdot \overrightarrow{t_{v}})+k \cdot E_{t_{n} \sim P_{D}}[\log \sigma(-\overrightarrow{s_{u}} \cdot \overrightarrow{t_{n}})] \\
&amp;= \sum_{u} \sum_{v} \# \text {Sampled}_{u}(v) \cdot \left(\log \sigma(\overrightarrow{s_{u}} \cdot \overrightarrow{t_{v}}) + k \cdot E_{t_{n} \sim P_{D}}[\log \sigma(-\overrightarrow{s_{u}} \cdot \overrightarrow{t_{n}})]\right)
\end{aligned}
$$</code></p>

<p>其中，我们根据分布 <code>$P_D \left(n\right) \sim \dfrac{1}{|V|}$</code> 随机负采样 <code>$k$</code> 个节点对，<code>$\# \text{Sampled}_{u}(v)$</code> 为采样的 <code>$\left(u, v\right)$</code> 对的个数，<code>$\sigma$</code> 为 sigmoid 函数。通常情况下，<code>$\# \text{Sampled}_{u}(v) \neq \# \text{Sampled}_{v}(u)$</code>，即 <code>$\left(u, v\right)$</code> 和 <code>$\left(v, u\right)$</code> 的观测数量是不同的。模型利用 Monte-Carlo End-Point 采样方法 <sup class="footnote-ref" id="fnref:fogaras2005towards"><a href="#fn:fogaras2005towards">6</a></sup> 随机的以 <code>$v$</code> 为起点和 <code>$\alpha$</code> 为停止概率采样 <code>$p$</code> 条路径。这种采样方式可以用于估计任意一个节点对之间的 Rooted PageRank <sup class="footnote-ref" id="fnref:haveliwala2002topic"><a href="#fn:haveliwala2002topic">7</a></sup> 值，模型利用这个值估计由 <code>$v$</code> 到达 <code>$u$</code> 的概率。</p>

<h3 id="matrix-fractorization">Matrix Fractorization</h3>

<h4 id="grarep">GraRep</h4>

<p>GraRep <sup class="footnote-ref" id="fnref:cao2015grarep"><a href="#fn:cao2015grarep">8</a></sup> 提出了一种基于矩阵分解的图嵌入方法。对于一个图 <code>$G$</code>，利用邻接矩阵 <code>$S$</code> 定义图的度矩阵：</p>

<p><code>$$
D_{i j}=\left\{\begin{array}{ll}
\sum_{p} S_{i p}, &amp; \text { if } i=j \\
0, &amp; \text { if } i \neq j
\end{array}\right.
$$</code></p>

<p>则一阶转移概率矩阵定义如下：</p>

<p><code>$$
A = D^{-1} S
$$</code></p>

<p>其中，<code>$A_{i, j}$</code> 表示通过一步由 <code>$v_i$</code> 转移到 <code>$v_j$</code> 的概率。所谓的全局特征包含两个部分：</p>

<ol>
<li>捕获两个节点之间的长距离特征</li>
<li>分别考虑按照不同转移步数的连接</li>
</ol>

<p>下图展示了 <code>$k = 1, 2, 3, 4$</code> 情况下的强（上）弱（下）关系：</p>

<figure>
  <img data-src="/images/cn/2020-04-11-graph-embedding-and-gnn/grarep.png" class="lazyload"/>
  
</figure>

<p>利用 Skip-Gram 和 NCE（noise contrastive estimation）方法，对于一个 <code>$k$</code> 阶转移，可以将模型归结到一个矩阵 <code>$Y_{i, j}^k$</code> 的分解问题：</p>

<p><code>$$
Y_{i, j}^{k}=W_{i}^{k} \cdot C_{j}^{k}=\log \left(\frac{A_{i, j}^{k}}{\sum_{t} A_{t, j}^{k}}\right)-\log (\beta)
$$</code></p>

<p>其中，<code>$W$</code> 和 <code>$C$</code> 的每一行分别为节点 <code>$w$</code> 和 <code>$c$</code> 的表示，<code>$\beta = \lambda / N$</code>，<code>$\lambda$</code> 为负采样的数量，<code>$N$</code> 为图中边的个数。</p>

<p>之后为了减少噪音，模型将 <code>$Y^k$</code> 中所有的负值替换为 0，通过 SVD（方法详情见参见<a href="/cn/2017/12/evd-svd-and-pca/">之前博客</a>）得到节点的 <code>$d$</code> 维表示：</p>

<p><code>$$
\begin{aligned}
X_{i, j}^{k} &amp;= \max \left(Y_{i, j}^{k}, 0\right) \\
X^{k} &amp;= U^{k} \Sigma^{k}\left(V^{k}\right)^{T} \\
X^{k} \approx X_{d}^{k} &amp;= U_{d}^{k} \Sigma_{d}^{k}\left(V_{d}^{k}\right)^{T} \\
X^{k} \approx X_{d}^{k} &amp;= W^{k} C^{k} \\
W^{k} &amp;= U_{d}^{k}\left(\Sigma_{d}^{k}\right)^{\frac{1}{2}} \\
C^{k} &amp;= \left(\Sigma_{d}^{k}\right)^{\frac{1}{2}} V_{d}^{k T}
\end{aligned}
$$</code></p>

<p>最终，通过对不同 <code>$k$</code> 的表示进行拼接得到节点最终的表示。</p>

<h4 id="hope">HOPE</h4>

<p>HOPE <sup class="footnote-ref" id="fnref:ou2016asymmetric"><a href="#fn:ou2016asymmetric">9</a></sup> 对于每个节点最终生成两个嵌入表示：一个是作为源节点的嵌入表示，另一个是作为目标节点的嵌入表示。模型通过近似高阶相似性来保留非对称传递性，其优化目标为：</p>

<p><code>$$
\min \left\|\mathbf{S}-\mathbf{U}^{s} \cdot \mathbf{U}^{t^{\top}}\right\|_{F}^{2}
$$</code></p>

<p>其中，<code>$\mathbf{S}$</code> 为相似矩阵，<code>$\mathbf{U}^s$</code> 和 <code>$\mathbf{U}^t$</code> 分别为源节点和目标节点的向量表示。下图展示了嵌入向量可以很好的保留非对称传递性：</p>

<figure>
  <img data-src="/images/cn/2020-04-11-graph-embedding-and-gnn/hope.png" class="lazyload"/>
  
</figure>

<p>对于 <code>$\mathbf{S}$</code> 有多种可选近似度量方法：Katz Index，Rooted PageRank（RPR），Common Neighbors（CN），Adamic-Adar（AA）。这些度量方法可以分为两类：全局近似（Katz Index 和 RPR）和局部近似（CN 和 AA）。</p>

<p>算法采用了一个广义 SVD 算法（JDGSVD）来解决使用原始 SVD 算法计算复杂度为<code>$O \left(N^3\right)$</code> 过高的问题，从而使得算法可以应用在更大规模的图上。</p>

<h3 id="meta-paths">Meta Paths</h3>

<h4 id="matapath2vec">matapath2vec</h4>

<p>matapath2vec <sup class="footnote-ref" id="fnref:dong2017metapath2vec"><a href="#fn:dong2017metapath2vec">10</a></sup> 提出了一种基于元路径的异构网络表示学习方法。在此我们引入 3 个定义：</p>

<ol>
<li><strong>异构网络（(Heterogeneous information network，HIN）</strong>可以定义为一个有向图 <code>$G = \left(V, E\right)$</code>，一个节点类型映射 <code>$\tau: V \to A$</code> 和一个边类型映射 <code>$\phi: E \to R$</code>，其中对于 <code>$v \in V$</code> 有 <code>$\tau \left(v\right) \in A$</code>，<code>$e \in E$</code> 有 <code>$\phi \left(e\right) \in R$</code>，且 <code>$|A| + |R| &gt; 1$</code>。</li>
<li><strong>网络模式（Network schema）</strong>定义为 <code>$T_G = \left(A, R\right)$</code>，为一个包含节点类型映射 <code>$\tau \left(v\right) \in A$</code> 和边映射 <code>$\phi \left(e\right) \in R$</code> 异构网络的 <code>$G = \left(V, E\right)$</code> 的元模板。</li>
<li><strong>元路径（Meta-path）</strong>定义为网络模式 <code>$T_G = \left(A, R\right)$</code> 上的一条路径 <code>$P$</code>，形式为 <code>$A_{1} \stackrel{R_{1}}{\longrightarrow} A_{2} \stackrel{R_{2}}{\longrightarrow} \cdots \stackrel{R_{l}}{\longrightarrow} A_{l+1}$</code>。</li>
</ol>

<p>下图展示了一个学术网络和部分元路径：</p>

<figure>
  <img data-src="/images/cn/2020-04-11-graph-embedding-and-gnn/metapaths.png" class="lazyload"/>
  
</figure>

<p>其中，APA 表示一篇论文的共同作者，APVPA 表示两个作者在同一个地方发表过论文。</p>

<p>metapath2vec 采用了基于元路径的随机游走来生成采样序列，这样就可以保留原始网络中的语义信息。对于一个给定的元路径模板 <code>$P: A_{1} \stackrel{R_{1}}{\longrightarrow} A_{2} \stackrel{R_{2}}{\longrightarrow} \cdots A_{t} \stackrel{R_{t}}{\longrightarrow} A_{t+1} \cdots \stackrel{R_{l}}{\longrightarrow} A_{l}$</code>，第 <code>$i$</code> 步的转移概率为：</p>

<p><code>$$
p\left(v^{i+1} | v_{t}^{i}, P\right)=\left\{\begin{array}{ll}
\dfrac{1}{\left|N_{t+1}\left(v_{t}^{i}\right)\right|} &amp; \left(v_{t}^{i}, v^{i+1}\right) \in E, \phi\left(v^{i+1}\right)=A_{t+1} \\
0 &amp; \left(v_{t}^{i}, v^{i+1}\right) \in E, \phi\left(v^{i+1}\right) \neq A_{t+1} \\
0 &amp; \left(v_{t}^{i}, v^{i+1}\right) \notin E
\end{array}\right.
$$</code></p>

<p>其中，<code>$v^i_t \in A_t$</code>，<code>$N_{t+1} \left(v^i_t\right)$</code> 表示节点 <code>$v^i_t$</code> 类型为 <code>$A_{t+1}$</code> 的邻居。之后，则采用了类似 DeepWalk 的方式进行训练得到节点表示。</p>

<h4 id="hin2vec">HIN2Vec</h4>

<p>HIN2Vec <sup class="footnote-ref" id="fnref:fu2017hin2vec"><a href="#fn:fu2017hin2vec">11</a></sup> 提出了一种利用多任务学习通过多种关系进行节点和元路径表示学习的方法。模型最初是希望通过一个多分类模型来预测任意两个节点之间所有可能的关系。假设对于任意两个节点，所有可能的关系集合为 <code>$R = \{\text{P-P, P-A, A-P, P-P-P, P-P-A, P-A-P, A-P-P, A-P-A}\}$</code>。假设一个实例 <code>$P_1$</code> 和 <code>$A_1$</code> 包含两种关系：<code>$\text{P-A}$</code> 和 <code>$\text{P-P-A}$</code>，则对应的训练数据为 <code>$\langle x: P_1, y: A_1, output: \left[0, 1, 0, 0, 1, 0, 0, 0\right] \rangle$</code>。</p>

<p>但实际上，扫描整个网络寻找所有可能的关系是不现实的，因此 HIN2Vec 将问题简化为一个给定两个节点判断之间是否存在一个关系的二分类问题，如下图所示：</p>

<figure>
  <img data-src="/images/cn/2020-04-11-graph-embedding-and-gnn/hin2vec.png" class="lazyload"/>
  
</figure>

<p>模型的三个输入分别为节点 <code>$x$</code> 和 <code>$y$</code>，以及关系 <code>$r$</code>。在隐含层输入被转换为向量 <code>$W_{X}^{\prime} \vec{x}, W_{Y}^{\prime} \vec{y}$</code> 和 <code>$f_{01}\left(W_{R}^{\prime} \vec{r}\right)$</code>。需要注意对于关系 <code>$r$</code>，模型应用了一个正则化函数 <code>$f_{01} \left(\cdot\right)$</code> 使得 <code>$r$</code> 的向量介于 <code>$0$</code> 和 <code>$1$</code> 之间。之后采用逐元素相乘对三个向量进行汇总 <code>$W_{X}^{\prime} \vec{x} \odot W_{Y}^{\prime} \vec{y} \odot f_{01}\left(W_{R}^{\prime} \vec{r}\right)$</code>。在最后的输出层，通过计算 <code>$sigmoid \left(\sum W_{X}^{\prime} \vec{x} \odot W_{Y}^{\prime} \vec{y} \odot f_{01}\left(W_{R}^{\prime} \vec{r}\right)\right)$</code> 得到最终的预测值。</p>

<p>在生成训练数据时，HIN2Vec 采用了完全随机游走进行节点采样，而非 metapath2vec 中的按照给定的元路径的方式。通过随机替换 <code>$x, y, r$</code> 中的任何一个可以生成负样本，但当网络中的关系数量较少，节点数量远远大于关系数量时，这种方式很可能产生错误的负样本，因此 HIN2Vec 只随机替换 <code>$x, y$</code>，保持 <code>$r$</code> 不变。</p>

<h3 id="deep-learning">Deep Learning</h3>

<h4 id="sdne">SDNE</h4>

<p>SDNE <sup class="footnote-ref" id="fnref:wang2016structural"><a href="#fn:wang2016structural">12</a></sup> 提出了一种利用自编码器同时优化一阶和二阶相似度的图嵌入算法，学习得到的向量能够保留局部和全局的结构信息。SDNE 使用的网络结构如下图所示：</p>

<figure>
  <img data-src="/images/cn/2020-04-11-graph-embedding-and-gnn/sdne.png" class="lazyload"/>
  
</figure>

<p>对于二阶相似度，自编码器的目标是最小化输入和输出的重构误差。SDNE 采用邻接矩阵作为自编码器的输入，<code>$\mathbf{x}_i = \mathbf{s}_i$</code>，每个 <code>$\mathbf{s}_i$</code> 包含了节点 <code>$v_i$</code> 的邻居结构信息。模型的损失函数如下：</p>

<p><code>$$
\mathcal{L}=\sum_{i=1}^{n}\left\|\hat{\mathbf{x}}_{i}-\mathbf{x}_{i}\right\|_{2}^{2}
$$</code></p>

<p>由于网络的稀疏性，邻接矩阵中的非零元素远远少于零元素，因此模型采用了一个带权的损失函数：</p>

<p><code>$$
\begin{aligned}
\mathcal{L}_{2nd} &amp;=\sum_{i=1}^{n}\left\|\left(\hat{\mathbf{x}}_{i}-\mathbf{x}_{i}\right) \odot \mathbf{b}_{i}\right\|_{2}^{2} \\
&amp;=\|(\hat{X}-X) \odot B\|_{F}^{2}
\end{aligned}
$$</code></p>

<p>其中，<code>$\odot$</code> 表示按位乘，<code>$\mathbf{b}_i = \left\{b_{i, j}\right\}_{j=1}^{n}$</code>，如果 <code>$s_{i, j} = 0$</code> 则 <code>$b_{i, j} = 1$</code> 否则 <code>$b_{i, j} = \beta &gt; 1$</code>。</p>

<p>对于一阶相似度，模型利用了一个监督学习模块最小化节点在隐含空间中距离。损失函数如下：</p>

<p><code>$$
\begin{aligned}
\mathcal{L}_{1st} &amp;=\sum_{i, j=1}^{n} s_{i, j}\left\|\mathbf{y}_{i}^{(K)}-\mathbf{y}_{j}^{(K)}\right\|_{2}^{2} \\
&amp;=\sum_{i, j=1}^{n} s_{i, j}\left\|\mathbf{y}_{i}-\mathbf{y}_{j}\right\|_{2}^{2}
\end{aligned}
$$</code></p>

<p>最终，模型联合损失函数如下：</p>

<p><code>$$
\begin{aligned}
\mathcal{L}_{mix} &amp;=\mathcal{L}_{2nd}+\alpha \mathcal{L}_{1st}+\nu \mathcal{L}_{reg} \\
&amp;=\|(\hat{X}-X) \odot B\|_{F}^{2}+\alpha \sum_{i, j=1}^{n} s_{i, j}\left\|\mathbf{y}_{i}-\mathbf{y}_{j}\right\|_{2}^{2}+\nu \mathcal{L}_{reg}
\end{aligned}
$$</code></p>

<p>其中，<code>$\mathcal{L}_{reg}$</code> 为 L2 正则项。</p>

<h4 id="dngr">DNGR</h4>

<p>DNGR <sup class="footnote-ref" id="fnref:cao2016deep"><a href="#fn:cao2016deep">13</a></sup> 提出了一种利用基于 Stacked Denoising Autoencoder（SDAE）提取特征的网络表示学习算法。算法的流程如下图所示：</p>

<figure>
  <img data-src="/images/cn/2020-04-11-graph-embedding-and-gnn/dngr.png" class="lazyload"/>
  
</figure>

<p>模型首先利用 Random Surfing 得到一个概率共现（PCO）矩阵，之后利用其计算得到 PPMI 矩阵，最后利用 SDAE 进行特征提取得到节点的向量表示。</p>

<p>对于传统的将图结构转换为一个线性序列方法存在几点缺陷：</p>

<ol>
<li>采样序列边缘的节点的上下文信息很难被捕捉。</li>
<li>很难直接确定游走的长度和步数等超参数，尤其是对于大型网络来说。</li>
</ol>

<p>受 PageRank 思想影响，作者采用了 Random Surfing 模型。定义转移矩阵 <code>$A$</code>，引入行向量 <code>$p_k$</code>，第 <code>$j$</code> 个元素表示通过 <code>$k$</code> 步转移之后到达节点 <code>$j$</code> 的概率。<code>$p_0$</code> 为一个初始向量，其仅第 <code>$i$</code> 个元素为 1，其它均为 0。在考虑以 <code>$1 - \alpha$</code> 的概率返回初始节点的情况下有：</p>

<p><code>$$
p_{k}=\alpha \cdot p_{k-1} A+(1-\alpha) p_{0}
$$</code></p>

<p>在不考虑返回初始节点的情况下有：</p>

<p><code>$$
p_{k}^{*}=p_{k-1}^{*} A=p_{0} A^{k}
$$</code></p>

<p>直观而言，两个节点越近，两者的关系越亲密，因此通过同当前节点的相对距离来衡量上下文节点的重要性是合理的。基于此，第 <code>$i$</code> 个节点的表示可以用如下方式构造：</p>

<p><code>$$
r=\sum_{k=1}^{K} w(k) \cdot p_{k}^{*}
$$</code></p>

<p>其中，<code>$w \left(\cdot\right)$</code> 是一个衰减函数。</p>

<p>利用 PCO 计算得到 PPMI 后，再利用一个 SDAE 进行特征提取。Stacking 策略可以通过不同的网络层学习得到不同层级的表示，Denoising 策略则通过去除数据中的噪声，增加结果的鲁棒性。同时，SNGR 相比基于 SVD 的方法效率更高。</p>

<h3 id="others">Others</h3>

<h4 id="line">LINE</h4>

<p>LINE <sup class="footnote-ref" id="fnref:tang2015line"><a href="#fn:tang2015line">14</a></sup> 提出了一个用于大规模网络嵌入的方法，其满足如下 3 个要求：</p>

<ol>
<li>同时保留节点之间的一阶相似性（first-order proximity）和二阶相似性（second-order proximity）。</li>
<li>可以处理大规模网络，例如：百万级别的顶点和十亿级别的边。</li>
<li>可以处理有向，无向和带权的多种类型的图结构。</li>
</ol>

<p>给定一个无向边 <code>$\left(i, j\right)$</code>，点 <code>$v_i$</code> 和 <code>$v_j$</code> 的联合概率如下：</p>

<p><code>$$
p_{1}\left(v_{i}, v_{j}\right)=\frac{1}{1+\exp \left(-\vec{u}_{i}^{T} \cdot \vec{u}_{j}\right)}
$$</code></p>

<p>其中，<code>$\vec{u}_{i} \in R^{d}$</code> 为节点 <code>$v_i$</code> 的低维向量表示。在空间 <code>$V \times V$</code> 上，分布 <code>$p \left(\cdot, \cdot\right)$</code> 的经验概率为 <code>$\hat{p}_1 \left(i, j\right) = \dfrac{w_{ij}}{V}$</code>，其中 <code>$W = \sum_{\left(i, j\right) \in E} w_{ij}$</code>。通过最小化两个分布的 KL 散度来优化模型，则目标函数定义如下：</p>

<p><code>$$
O_{1}=-\sum_{(i, j) \in E} w_{i j} \log p_{1}\left(v_{i}, v_{j}\right)
$$</code></p>

<p>需要注意的是一阶相似度仅可用于无向图，通过最小化上述目标函数，我们可以将任意顶点映射到一个 <code>$d$</code> 维空间向量。</p>

<p>二阶相似度既可以用于无向图，也可以用于有向图。二阶相似度假设共享大量同其他节点连接的节点之间是相似的，每个节点被视为一个特定的上下文，则在上下文上具有类似分布的节点是相似的。在此，引入两个向量 <code>$\vec{u}_{i}$</code> 和 <code>$\vec{u}_{\prime i}$</code>，其中 <code>$\vec{u}_{i}$</code> 是 <code>$v_i$</code> 做为节点的表示，<code>$\vec{u}_{\prime i}$</code> 是 <code>$v_i$</code> 做为上下文的表示。对于一个有向边 <code>$\left(i, j\right)$</code>，由 <code>$v_i$</code> 生成上下文 <code>$v_j$</code> 的概率为：</p>

<p><code>$$
p_{2}\left(v_{j} | v_{i}\right)=\frac{\exp \left(\vec{u}_{j}^{\prime T} \cdot \vec{u}_{i}\right)}{\sum_{k=1}^{|V|} \exp \left(\vec{u}_{k}^{\prime T} \cdot \vec{u}_{i}\right)}
$$</code></p>

<p>其中，<code>$|V|$</code> 为节点或上下文的数量。在此我们引入一个参数 <code>$\lambda_i$</code> 用于表示节点 <code>$v_i$</code> 的重要性程度，重要性程度可以利用度或者 PageRank 算法进行估计。经验分布 <code>$\hat{p}_{2}\left(\cdot \mid v_{i}\right)$</code> 定义为 <code>$\hat{p}_{2}\left(v_{j} \mid v_{i}\right)=\dfrac{w_{i j}}{d_{i}}$</code>，其中 <code>$w_{ij}$</code> 为边 <code>$\left(i, j\right)$</code> 的权重，<code>$d_i$</code> 为节点 <code>$v_i$</code> 的出度。LINE 中采用 <code>$d_i$</code> 作为节点的重要性 <code>$\lambda_i$</code>，利用 KL 散度同时忽略一些常量，目标函数定义如下：</p>

<p><code>$$
O_{2}=-\sum_{(i, j) \in E} w_{i j} \log p_{2}\left(v_{j} \mid v_{i}\right)
$$</code></p>

<p>LINE 采用负采样的方式对模型进行优化，同时利用 Alias 方法 <sup class="footnote-ref" id="fnref:walker1974new"><a href="#fn:walker1974new">15</a></sup> <sup class="footnote-ref" id="fnref:walker1977efficient"><a href="#fn:walker1977efficient">16</a></sup> 加速采样过程。</p>

<h2 id="图神经网络">图神经网络</h2>

<blockquote>
<p>本节内容主要参考自：<br />
Deep Learning on Graphs: A Survey <sup class="footnote-ref" id="fnref:zhang2020deep"><a href="#fn:zhang2020deep">17</a></sup><br />
A Comprehensive Survey on Graph Neural Networks <sup class="footnote-ref" id="fnref:wu2020comprehensive"><a href="#fn:wu2020comprehensive">18</a></sup><br />
Graph Neural Networks: A Review of Methods and Applications <sup class="footnote-ref" id="fnref:zhou2018graph"><a href="#fn:zhou2018graph">19</a></sup><br />
Introduction to Graph Neural Networks <sup class="footnote-ref" id="fnref:liu2020introduction"><a href="#fn:liu2020introduction">20</a></sup></p>
</blockquote>

<p>图神经网络（Graph Neural Network，GNN）最早由 Scarselli 等人 <sup class="footnote-ref" id="fnref:scarselli2008graph"><a href="#fn:scarselli2008graph">21</a></sup> 提出。图中的一个节点可以通过其特征和相关节点进行定义，GNN 的目标是学习一个状态嵌入 <code>$\mathbf{h}_v \in \mathbb{R}^s$</code> 用于表示每个节点的邻居信息。状态嵌入 <code>$\mathbf{h}_v$</code> 可以生成输出向量 <code>$\mathbf{o}_v$</code> 用于作为预测节点标签的分布等。</p>

<p>下面三张图分别从图的类型，训练方法和传播过程角度列举了不同 GNN 的变种 <sup class="footnote-ref" id="fnref:zhou2018graph"><a href="#fn:zhou2018graph">19</a></sup>。</p>

<figure>
  <img data-src="/images/cn/2020-04-11-graph-embedding-and-gnn/gnn-graph-types.png" class="lazyload"/>
  
</figure>

<figure>
  <img data-src="/images/cn/2020-04-11-graph-embedding-and-gnn/gnn-training-methods.png" class="lazyload"/>
  
</figure>

<figure>
  <img data-src="/images/cn/2020-04-11-graph-embedding-and-gnn/gnn-propagation-steps.png" class="lazyload"/>
  
</figure>

<p>下面我们主要从模型的角度分别介绍不同种类的 GNN。</p>

<h3 id="graph-neural-networks">Graph Neural Networks</h3>

<p>为了根据邻居更新节点的状态，定义一个用于所有节点的函数 <code>$f$</code>，称之为 <em>local transition function</em>。定义一个函数 <code>$g$</code>，用于生成节点的输出，称之为 <em>local output function</em>。有：</p>

<p><code>$$
\begin{array}{c}
\mathbf{h}_{v}=f\left(\mathbf{x}_{v}, \mathbf{x}_{co[v]}, \mathbf{h}_{ne[v]}, \mathbf{x}_{ne[v])}\right. \\
\mathbf{o}_{v}=g\left(\mathbf{h}_{v}, \mathbf{x}_{v}\right)
\end{array}
$$</code></p>

<p>其中，<code>$\mathbf{x}$</code> 表示输入特征，<code>$\mathbf{h}$</code> 表示隐含状态。<code>$co[v]$</code> 为连接到节点 <code>$v$</code> 的边集，<code>$ne[v]$</code> 为节点 <code>$v$</code> 的邻居。</p>

<figure>
  <img data-src="/images/cn/2020-04-11-graph-embedding-and-gnn/graph-example.png" class="lazyload"/>
  
</figure>

<p>上图中，<code>$\mathbf{x}_1$</code> 表示 <code>$l_1$</code> 的输入特征，<code>$co[l_1]$</code> 包含了边 <code>$l_{(1, 4)}, l_{(6, 1)}, l_{(1, 2)}$</code> 和 <code>$l_{(3, 1)}$</code>，<code>$ne[l_1]$</code> 包含了节点 <code>$l_2, k_3, l_4$</code> 和 <code>$l_6$</code>。</p>

<p>令 <code>$\mathbf{H}, \mathbf{O}, \mathbf{X}$</code> 和 <code>$\mathbf{X}_N$</code> 分别表示状态、输出、特征和所有节点特征的向量，有：</p>

<p><code>$$
\begin{aligned}
&amp;\mathbf{H}=F(\mathbf{H}, \mathbf{X})\\
&amp;\mathbf{O}=G\left(\mathbf{H}, \mathbf{X}_{N}\right)
\end{aligned}
$$</code></p>

<p>其中，<code>$F$</code> 为 <em>global transition function</em>，<code>$G$</code> 为 <em>global output function</em>，分别为图中所有节点的 local transition function <code>$f$</code> 和 local output function <code>$g$</code> 的堆叠版本。依据 Banach 的 Fixed Point Theorem <sup class="footnote-ref" id="fnref:khamsi2011introduction"><a href="#fn:khamsi2011introduction">22</a></sup>，GNN 利用传统的迭代方式计算状态：</p>

<p><code>$$
\mathbf{H}^{t+1}=F\left(\mathbf{H}^{t}, \mathbf{X}\right)
$$</code></p>

<p>其中，<code>$\mathbf{H}^t$</code> 表示第  <code>$t$</code> 论循环 <code>$\mathbf{H}$</code> 的值。</p>

<p>介绍完 GNN 的框架后，下一个问题就是如果学习得到 local transition function <code>$f$</code> 和 local output function <code>$g$</code>。在包含目标信息（<code>$\mathbf{t}_v$</code> 对于特定节点）的监督学习情况下，损失为：</p>

<p><code>$$
loss = \sum_{i=1}^{p} \left(\mathbf{t}_i - \mathbf{o}_i\right)
$$</code></p>

<p>其中，<code>$p$</code> 为用于监督学习的节点数量。利用基于梯度下降的学习方法优化模型后，我们可以得到针对特定任务的训练模型和图中节点的隐含状态。</p>

<p>尽管实验结果表明 GNN 是一个用于建模结构数据的强大模型，但对于一般的 GNN 模型仍存在如下缺陷：</p>

<ol>
<li>对于固定点，隐含状态的更新是低效地。</li>
<li>GNN 在每一轮计算中共享参数，而常见的神经网络结构在不同层使用不同的参数。同时，隐含节点状态的更新可以进一步应用 RNN 的思想。</li>
<li>边上的一些信息特征并没有被有效的建模，同时如何学习边的隐含状态也是一个重要问题。</li>
<li>如果我们更关注节点的表示而非图的表示，当迭代轮数 <code>$T$</code> 很大时使用固定点是不合适的。这是因为固定点表示的分布在数值上会更加平滑，从而缺少用于区分不同节点的信息。</li>
</ol>

<h3 id="graph-convolutional-networks">Graph Convolutional Networks</h3>

<p>图卷积神经网络是将用于传统数据（例如：图像）的卷积操作应用到图结构的数据中。核心思想在于学习一个函数 <code>$f$</code>，通过聚合节点 <code>$v_i$</code> 自身的特征 <code>$\mathbf{X}_i$</code> 和邻居的特征 <code>$\mathbf{X}_j$</code> 获得节点的表示，其中 <code>$j \in N\left(v_i\right)$</code> 为节点的邻居。</p>

<p>下图展示了一个用于节点表示学习的 GCN 过程：</p>

<figure>
  <img data-src="/images/cn/2020-04-11-graph-embedding-and-gnn/gcn.png" class="lazyload"/>
  
</figure>

<p>GCN 在构建更复杂的图神经网路中扮演了一个核心角色：</p>

<figure>
  <img data-src="/images/cn/2020-04-11-graph-embedding-and-gnn/gcn-classification.png" class="lazyload"/>
  <figcaption><p class="figcaption">包含 Pooling 模块用于图分类的 GCN</p></figcaption>
</figure>

<figure>
  <img data-src="/images/cn/2020-04-11-graph-embedding-and-gnn/gcn-auto-encoder.png" class="lazyload"/>
  <figcaption><p class="figcaption">包含 GCN 的图自编码器</p></figcaption>
</figure>

<figure>
  <img data-src="/images/cn/2020-04-11-graph-embedding-and-gnn/gcn-graph-spatial-temporal-network.png" class="lazyload"/>
  <figcaption><p class="figcaption">包含 GCN 的图时空网络</p></figcaption>
</figure>

<p>GCN 方法可以分为两大类：基于频谱（Spectral Methods）和基于空间（Spatial Methods）的方法。</p>

<h4 id="基于频谱的方法-spectral-methods">基于频谱的方法（Spectral Methods）</h4>

<p>基于频谱的方法将图视为无向图进行处理，图的一种鲁棒的数学表示为标准化的图拉普拉斯矩阵：</p>

<p><code>$$
\mathbf{L}=\mathbf{I}_{\mathbf{n}}-\mathbf{D}^{-\frac{1}{2}} \mathbf{A} \mathbf{D}^{-\frac{1}{2}}
$$</code></p>

<p>其中，<code>$\mathbf{A}$</code> 为图的邻接矩阵，<code>$\mathbf{D}$</code> 为节点度的对角矩阵，<code>$\mathbf{D}_{ii} = \sum_{j} \left(\mathbf{A}_{i, j}\right)$</code>。标准化的拉普拉斯矩阵具有实对称半正定的性质，因此可以分解为：</p>

<p><code>$$
\mathbf{L}=\mathbf{U} \mathbf{\Lambda} \mathbf{U}^{T}
$$</code></p>

<p>其中，<code>$\mathbf{U}=\left[\mathbf{u}_{\mathbf{0}}, \mathbf{u}_{\mathbf{1}}, \cdots, \mathbf{u}_{\mathbf{n}-\mathbf{1}}\right] \in \mathbf{R}^{N \times N}$</code> 是由 <code>$\mathbf{L}$</code> 的特征向量构成的矩阵，<code>$\mathbf{\Lambda}$</code> 为特征值的对角矩阵，<code>$\mathbf{\Lambda}_{ii} = \lambda_i$</code>。在图信号处理过程中，一个图信号 <code>$\mathbf{x} \in \mathbb{R}^N$</code> 是一个由图的节点构成的特征向量，其中 <code>$\mathbf{x}_i$</code> 表示第 <code>$i$</code> 个节点的值。对于信号 <code>$\mathbf{x}$</code>，图上的傅里叶变换可以定义为：</p>

<p><code>$$
\mathscr{F}(\mathbf{x})=\mathbf{U}^{T} \mathbf{x}
$$</code></p>

<p>傅里叶反变换定义为：</p>

<p><code>$$
\mathscr{F}^{-1}(\hat{\mathbf{x}})=\mathbf{U} \hat{\mathbf{x}}
$$</code></p>

<p>其中，<code>$\hat{\mathbf{x}}$</code> 为傅里叶变换后的结果。</p>

<p>转变后信号 <code>$\hat{\mathbf{x}}$</code> 的元素为新空间图信号的坐标，因此输入信号可以表示为：</p>

<p><code>$$
\mathbf{x}=\sum_{i} \hat{\mathbf{x}}_{i} \mathbf{u}_{i}
$$</code></p>

<p>这正是傅里叶反变换的结果。那么对于输入信号 <code>$\mathbf{x}$</code> 的图卷积可以定义为：</p>

<p><code>$$
\begin{aligned}
\mathbf{x} *_{G} \mathbf{g} &amp;=\mathscr{F}^{-1}(\mathscr{F}(\mathbf{x}) \odot \mathscr{F}(\mathbf{g})) \\
&amp;=\mathbf{U}\left(\mathbf{U}^{T} \mathbf{x} \odot \mathbf{U}^{T} \mathbf{g}\right)
\end{aligned}
$$</code></p>

<p>其中，<code>$\mathbf{g} \in \mathbb{R}^N$</code> 为滤波器，<code>$\odot$</code> 表示逐元素乘。假设定义一个滤波器 <code>$\mathbf{g}_{\theta}=\operatorname{diag}\left(\mathbf{U}^{T} \mathbf{g}\right)$</code>，则图卷积可以简写为：</p>

<p><code>$$
\mathbf{x} *_{G} \mathbf{g}_{\theta}=\mathbf{U} \mathbf{g}_{\theta} \mathbf{U}^{T} \mathbf{x}
$$</code></p>

<p>基于频谱的图卷积网络都遵循这样的定义，不同之处在于不同滤波器的选择。</p>

<p>一些代表模型及其聚合和更新方式如下表所示：</p>

<table>
<thead>
<tr>
<th>模型</th>
<th>聚合方式</th>
<th>更新方式</th>
</tr>
</thead>

<tbody>
<tr>
<td>ChebNet <sup class="footnote-ref" id="fnref:defferrard2016convolutional"><a href="#fn:defferrard2016convolutional">23</a></sup></td>
<td><code>$\mathbf{N}_{k}=\mathbf{T}_{k}(\tilde{\mathbf{L}}) \mathbf{X}$</code></td>
<td><code>$\mathbf{H}=\sum_{k=0}^{K} \mathbf{N}_{k} \mathbf{\Theta}_{k}$</code></td>
</tr>

<tr>
<td>1st-order model</td>
<td><code>$\begin{array}{l} \mathbf{N}_{0}=\mathbf{X} \\ \mathbf{N}_{1}=\mathbf{D}^{-\frac{1}{2}} \mathbf{A} \mathbf{D}^{-\frac{1}{2}} \mathbf{X} \end{array}$</code></td>
<td><code>$\mathbf{H}=\mathbf{N}_{0} \mathbf{\Theta}_{0}+\mathbf{N}_{1} \mathbf{\Theta}_{1}$</code></td>
</tr>

<tr>
<td>Single parameter</td>
<td><code>$\mathbf{N}=\left(\mathbf{I}_{N}+\mathbf{D}^{-\frac{1}{2}} \mathbf{A} \mathbf{D}^{-\frac{1}{2}}\right) \mathbf{X}$</code></td>
<td><code>$\mathbf{H}=\mathbf{N} \mathbf{\Theta}$</code></td>
</tr>

<tr>
<td>GCN <sup class="footnote-ref" id="fnref:kipf2016semi"><a href="#fn:kipf2016semi">24</a></sup></td>
<td><code>$\mathbf{N}=\tilde{\mathbf{D}}^{-\frac{1}{2}} \tilde{\mathbf{A}} \tilde{\mathbf{D}}^{-\frac{1}{2}} \mathbf{X}$</code></td>
<td><code>$\mathbf{H}=\mathbf{N} \mathbf{\Theta}$</code></td>
</tr>
</tbody>
</table>

<h4 id="基于空间的方法-spatial-methods">基于空间的方法（Spatial Methods）</h4>

<p>基于空间的方法通过节点的空间关系来定义图卷积操作。为了将图像和图关联起来，可以将图像视为一个特殊形式的图，每个像素点表示一个节点，如下图所示：</p>

<figure>
  <img data-src="/images/cn/2020-04-11-graph-embedding-and-gnn/spatial-based-gcn.png" class="lazyload"/>
  
</figure>

<p>每个像素同周围的像素相连，以 <code>$3 \times 3$</code> 为窗口，每个节点被 8 个邻居节点所包围。通过对中心节点和周围邻居节点的像素值进行加权平均来应用一个 <code>$3 \times 3$</code> 大小的滤波器。由于邻居节点的特定顺序，可以在不同位置共享权重。同样对于一般的图，基于空间的图卷积通过对中心和邻居节点的聚合得到节点新的表示。</p>

<p>为了使节点可以感知更深和更广的范围，通常的做法是将多个图卷积层堆叠在一起。根据堆叠方式的不同，基于空间的图卷积可以进一步分为两类：基于循环（Recurrent-based）和基于组合（Composition-based）的。基于循环的方法使用相同的图卷积层来更新隐含表示，基于组合的方式使用不同的图卷积层更新隐含表示，两者差异如下图所示：</p>

<figure>
  <img data-src="/images/cn/2020-04-11-graph-embedding-and-gnn/recurrent-based-vs-composition-based.png" class="lazyload"/>
  
</figure>

<p>一些代表模型及其聚合和更新方式如下表所示：</p>

<table>
<thead>
<tr>
<th>模型</th>
<th>聚合方式</th>
<th>更新方式</th>
</tr>
</thead>

<tbody>
<tr>
<td>Neural FPs <sup class="footnote-ref" id="fnref:duvenaud2015convolutional"><a href="#fn:duvenaud2015convolutional">25</a></sup></td>
<td><code>$\mathbf{h}_{\mathcal{N}_{v}}^{t}=\mathbf{h}_{v}^{t-1}+\sum_{k=1}^{\mathcal{N}_{v}} \mathbf{h}_{k}^{t-1}$</code></td>
<td><code>$\mathbf{h}_{v}^{t}=\sigma\left(\mathbf{h}_{\mathcal{N}_{v}}^{t} \mathbf{W}_{L}^{\mathcal{N}_{v}}\right)$</code></td>
</tr>

<tr>
<td>DCNN <sup class="footnote-ref" id="fnref:atwood2016diffusion"><a href="#fn:atwood2016diffusion">26</a></sup></td>
<td>Node classification:<br/><code>$\mathbf{N}=\mathbf{P}^{*} \mathbf{X}$</code><br/> Graph classification:<br/><code>$\mathbf{N}=1_{N}^{T} \mathbf{P}^{*} \mathbf{X} / N$</code></td>
<td><code>$\mathbf{H}=f\left(\mathbf{W}^{c} \odot \mathbf{N}\right)$</code></td>
</tr>

<tr>
<td>GraphSAGE <sup class="footnote-ref" id="fnref:hamilton2017inductive"><a href="#fn:hamilton2017inductive">27</a></sup></td>
<td><code>$\mathbf{h}_{\mathcal{N}_{v}}^{t}=\text{AGGREGATE}_{t}\left(\left\{\mathbf{h}_{u}^{t-1}, \forall u \in \mathcal{N}_{v}\right\}\right)$</code></td>
<td><code>$\mathbf{h}_{v}^{t}=\sigma\left(\mathbf{W}^{t} \cdot\left[\mathbf{h}_{v}^{t-1} \Vert \mathbf{h}_{\mathcal{N}_{v}}^{t}\right]\right)$</code></td>
</tr>
</tbody>
</table>

<h3 id="graph-recurrent-networks">Graph Recurrent Networks</h3>

<p>一些研究尝试利用门控机制（例如：GRU 或 LSTM）用于减少之前 GNN 模型在传播过程中的限制，同时改善在图结构中信息的长距离传播。GGNN <sup class="footnote-ref" id="fnref:li2015gated"><a href="#fn:li2015gated">28</a></sup> 提出了一种使用 GRU 进行传播的方法。它将 RNN 展开至一个固定 <code>$T$</code> 步，然后通过基于时间的传导计算梯度。传播模型的基础循环方式如下：</p>

<p><code>$$
\begin{aligned}
&amp;\mathbf{a}_{v}^{t}=\mathbf{A}_{v}^{T}\left[\mathbf{h}_{1}^{t-1} \ldots \mathbf{h}_{N}^{t-1}\right]^{T}+\mathbf{b}\\
&amp;\mathbf{z}_{v}^{t}=\sigma\left(\mathbf{W}^{z} \mathbf{a}_{v}^{t}+\mathbf{U}^{z} \mathbf{h}_{v}^{t-1}\right)\\
&amp;\mathbf{r}_{v}^{t}=\sigma\left(\mathbf{W}^{r} \mathbf{a}_{v}^{t}+\mathbf{U}^{r} \mathbf{h}_{v}^{t-1}\right)\\
&amp;\begin{array}{l}
\widetilde{\mathbf{h}}_{v}^{t}=\tanh \left(\mathbf{W} \mathbf{a}_{v}^{t}+\mathbf{U}\left(\mathbf{r}_{v}^{t} \odot \mathbf{h}_{v}^{t-1}\right)\right) \\
\mathbf{h}_{v}^{t}=\left(1-\mathbf{z}_{v}^{t}\right) \odot \mathbf{h}_{v}^{t-1}+\mathbf{z}_{v}^{t} \odot \widetilde{\mathbf{h}}_{v}^{t}
\end{array}
\end{aligned}
$$</code></p>

<p>节点 <code>$v$</code> 首先从邻居汇总信息，其中 <code>$\mathbf{A}_v$</code> 为图邻接矩阵 <code>$\mathbf{A}$</code> 的子矩阵表示节点 <code>$v$</code> 及其邻居的连接。类似 GRU 的更新函数，通过结合其他节点和上一时间的信息更新节点的隐状态。<code>$\mathbf{a}$</code> 用于获取节点 <code>$v$</code> 邻居的信息，<code>$\mathbf{z}$</code> 和 <code>$\mathbf{r}$</code> 分别为更新和重置门。</p>

<p>GGNN 模型设计用于解决序列生成问题，而之前的模型主要关注单个输出，例如：节点级别或图级别的分类问题。研究进一步提出了 Gated Graph Sequence Neural Networks（GGS-NNs），使用多个 GGNN 产生一个输出序列 <code>$\mathbf{o}^{(1)}, \cdots, \mathbf{o}^{(K)}$</code>，如下图所示：</p>

<figure>
  <img data-src="/images/cn/2020-04-11-graph-embedding-and-gnn/ggs-nn.png" class="lazyload"/>
  
</figure>

<p>上图中使用了两个 GGNN，<code>$\mathcal{F}_o^{(k)}$</code> 用于从 <code>$\mathcal{\boldsymbol{X}}^{(k)}$</code> 预测 <code>$\mathbf{o}^{(k)}$</code>，<code>$\mathcal{F}_x^{(k)}$</code> 用于从 <code>$\mathcal{\boldsymbol{X}}^{(k)}$</code> 预测 <code>$\mathcal{\boldsymbol{X}}^{(k+1)}$</code>。令 <code>$\mathcal{\boldsymbol{H}}^{(k, t)}$</code> 表示第 <code>$k$</code> 步输出的第 <code>$t$</code> 步传播，<code>$\mathcal{\boldsymbol{H}}^{(k, 1)}$</code> 在任意 <code>$k$</code> 步初始化为 <code>$\mathcal{\boldsymbol{X}}^{(k)}$</code>，<code>$\mathcal{\boldsymbol{H}}^{(t, 1)}$</code> 在任意 <code>$t$</code> 步初始化为 <code>$\mathcal{\boldsymbol{X}}^{(t)}$</code>，<code>$\mathcal{F}_o^{(k)}$</code> 和 <code>$\mathcal{F}_x^{(k)}$</code> 可以为不同模型也可以共享权重。</p>

<p>一些代表模型及其聚合和更新方式如下表所示：</p>

<table>
<thead>
<tr>
<th>模型</th>
<th>聚合方式</th>
<th>更新方式</th>
</tr>
</thead>

<tbody>
<tr>
<td>GGNN <sup class="footnote-ref" id="fnref:li2015gated"><a href="#fn:li2015gated">28</a></sup></td>
<td><code>$\mathbf{h}_{\mathcal{N}_{v}}^{t}=\sum_{k \in \mathcal{N}_{v}} \mathbf{h}_{k}^{t-1}+\mathbf{b}$</code></td>
<td><code>$\begin{aligned} &amp;\mathbf{z}_{v}^{t}=\sigma\left(\mathbf{W}^{z} \mathbf{h}_{\mathcal{N}_{v}}^{t}+\mathbf{U}^{z} \mathbf{h}_{v}^{t-1}\right)\\ &amp;\mathbf{r}_{v}^{t}=\sigma\left(\mathbf{W}^{r} \mathbf{h}_{\mathcal{N}_{v}}^{z}+\mathbf{U}^{r} \mathbf{h}_{v}^{t-1}\right)\\ &amp;\begin{array}{l} \widetilde{\mathbf{h}}_{v}^{t}=\tanh \left(\mathbf{W h}_{\mathcal{N}_{v}}^{t}+\mathbf{U}\left(\mathbf{r}_{v}^{t} \odot \mathbf{h}_{v}^{t-1}\right)\right) \\ \mathbf{h}_{v}^{t}=\left(1-\mathbf{z}_{v}^{t}\right) \odot \mathbf{h}_{v}^{t-1}+\mathbf{z}_{v}^{t} \odot \widetilde{\mathbf{h}}_{v}^{t} \end{array} \end{aligned}$</code></td>
</tr>

<tr>
<td>Tree LSTM (Child sum) <sup class="footnote-ref" id="fnref:tai2015improved"><a href="#fn:tai2015improved">29</a></sup></td>
<td><code>$\mathbf{h}_{\mathcal{N}_{v}}^{t}=\sum_{k \in \mathcal{N}_{v}} \mathbf{h}_{k}^{t-1}$</code></td>
<td><code>$\begin{aligned} &amp;\mathbf{i}_{v}^{t}=\sigma\left(\mathbf{W}^{i} \mathbf{x}_{v}^{t}+\mathbf{U}^{i} \mathbf{h}_{\mathcal{N}_{v}}^{t}+\mathbf{b}^{i}\right)\\ &amp;\mathbf{f}_{v k}^{t}=\sigma\left(\mathbf{W}^{f} \mathbf{x}_{v}^{t}+\mathbf{U}^{f} \mathbf{h}_{k}^{t-1}+\mathbf{b}^{f}\right)\\ &amp;\mathbf{o}_{v}^{t}=\sigma\left(\mathbf{W}^{o} \mathbf{x}_{v}^{t}+\mathbf{U}^{o} \mathbf{h}_{\mathcal{N}_{v}}^{t}+\mathbf{b}^{o}\right)\\ &amp;\mathbf{u}_{v}^{t}=\tanh \left(\mathbf{W}^{u} \mathbf{x}_{v}^{t}+\mathbf{U}^{u} \mathbf{h}_{\mathcal{N}_{v}}^{t}+\mathbf{b}^{u}\right)\\ &amp;\begin{array}{l} \mathbf{c}_{v}^{t}=\mathbf{i}_{v}^{t} \odot \mathbf{u}_{v}^{t}+\sum_{k \in \mathcal{N}_{v}} \mathbf{f}_{v k}^{t} \odot \mathbf{c}_{k}^{t-1} \\ \mathbf{h}_{v}^{t}=\mathbf{o}_{v}^{t} \odot \tanh \left(\mathbf{c}_{v}^{t}\right) \end{array} \end{aligned}$</code></td>
</tr>

<tr>
<td>Tree LSTM (N-ary) <sup class="footnote-ref" id="fnref:tai2015improved"><a href="#fn:tai2015improved">29</a></sup></td>
<td><code>$\begin{aligned} &amp;\mathbf{h}_{\mathcal{N}_{v}}^{t i}=\sum_{l=1}^{K} \mathbf{U}_{l}^{i} \mathbf{h}_{v l}^{t-1}\\ &amp;\mathbf{h}_{\mathcal{N}_{v} k}^{t f}=\sum_{l=1}^{K} \mathbf{U}_{k l}^{f} \mathbf{h}_{v l}^{t-1}\\ &amp;\mathbf{h}_{\mathcal{N}_{v}}^{t o}=\sum_{l=1}^{K} \mathbf{U}_{l}^{o} \mathbf{h}_{v l}^{t-1}\\ &amp;\mathbf{h}_{\mathcal{N}_{v}}^{t u}=\sum_{l=1}^{K} \mathbf{U}_{l}^{u} \mathbf{h}_{v l}^{t-1} \end{aligned}$</code></td>
<td><code>$\begin{aligned} &amp;\mathbf{i}_{v}^{t}=\sigma\left(\mathbf{W}^{i} \mathbf{x}_{v}^{t}+\mathbf{h}_{\mathcal{N}_{v},}^{t i}+\mathbf{b}^{i}\right)\\ &amp;\mathbf{f}_{v k}^{t}=\sigma\left(\mathbf{W}^{f} \mathbf{x}_{v}^{t}+\mathbf{h}_{\mathcal{N}_{v} k}^{f f}+\mathbf{b}^{f}\right)\\ &amp;\mathbf{o}_{v}^{t}=\sigma\left(\mathbf{W}^{o} \mathbf{x}_{v}^{t}+\mathbf{h}_{\mathcal{N}_{v}}^{t o}+\mathbf{b}^{o}\right)\\ &amp;\mathbf{u}_{v}^{t}=\tanh \left(\mathbf{W}^{u} \mathbf{x}_{v}^{t}+\mathbf{h}_{\mathcal{N}_{v}}^{t u}+\mathbf{b}^{u}\right)\\ &amp;\mathbf{c}_{v}^{t}=\mathbf{i}_{v}^{t} \odot \mathbf{u}_{v}^{t}+\sum_{l=1}^{K} \mathbf{f}_{v l}^{t} \odot \mathbf{c}_{v l}^{t-1}\\ &amp;\mathbf{h}_{v}^{t}=\mathbf{o}_{v}^{t} \odot \tanh \left(\mathbf{c}_{v}^{t}\right) \end{aligned}$</code></td>
</tr>

<tr>
<td>Graph LSTM <sup class="footnote-ref" id="fnref:peng2017cross"><a href="#fn:peng2017cross">30</a></sup></td>
<td><code>$\begin{aligned} \mathbf{h}_{\mathcal{N}_{v}}^{t i}=\sum_{k \in \mathcal{N}_{v}} \mathbf{U}_{m(v, k)}^{i} \mathbf{h}_{k}^{t-1} \\ \mathbf{h}_{\mathcal{N}_{v}}^{t o}=\sum_{k \in \mathcal{N}_{v}} \mathbf{U}_{m(v, k)}^{o} \mathbf{h}_{k}^{t-1} \\ \mathbf{h}_{\mathcal{N}_{v}}^{t u}=\sum_{k \in \mathcal{N}_{v}} \mathbf{U}_{m(v, k)}^{u} \mathbf{h}_{k}^{t-1} \end{aligned}$</code></td>
<td><code>$\begin{aligned} &amp;\mathbf{i}_{v}^{t}=\sigma\left(\mathbf{W}^{i} \mathbf{x}_{v}^{t}+\mathbf{h}_{\mathcal{N}_{v}}^{t i}+\mathbf{b}^{i}\right)\\ &amp;\mathbf{f}_{v k}^{t}=\sigma\left(\mathbf{W}^{f} \mathbf{x}_{v}^{t}+\mathbf{U}_{m(v, k)}^{f} \mathbf{h}_{k}^{t-1}+\mathbf{b}^{f}\right)\\ &amp;\mathbf{o}_{v}^{t}=\sigma\left(\mathbf{W}^{o} \mathbf{x}_{v}^{t}+\mathbf{h}_{\mathcal{N}_{v}}^{t o}+\mathbf{b}^{o}\right)\\ &amp;\mathbf{u}_{v}^{t}=\tanh \left(\mathbf{W}^{u} \mathbf{x}_{v}^{t}+\mathbf{h}_{\mathcal{N}_{v}}^{t u}+\mathbf{b}^{u}\right)\\ &amp;\begin{array}{l} \mathbf{c}_{v}^{t}=\mathbf{i}_{v}^{t} \odot \mathbf{u}_{v}^{t}+\sum_{k \in \mathcal{N}_{v}} \mathbf{f}_{v k}^{t} \odot \mathbf{c}_{k}^{t-1} \\ \mathbf{h}_{v}^{t}=\mathbf{o}_{v}^{t} \odot \tanh \left(\mathbf{c}_{v}^{t}\right) \end{array} \end{aligned}$</code></td>
</tr>
</tbody>
</table>

<h3 id="graph-attention-networks">Graph Attention Networks</h3>

<p>与 GCN 对于节点所有的邻居平等对待相比，注意力机制可以为每个邻居分配不同的注意力评分，从而识别更重要的邻居。</p>

<p>GAT <sup class="footnote-ref" id="fnref:velickovic2017graph"><a href="#fn:velickovic2017graph">31</a></sup> 将注意力机制引入传播过程，其遵循自注意力机制，通过对每个节点邻居的不同关注更新隐含状态。GAT 定义了一个图注意力层（<em>graph attentional layer</em>），通过堆叠构建图注意力网络。对于节点对 <code>$\left(i, j\right)$</code>，基于注意力机制的系数计算方式如下：</p>

<p><code>$$
\alpha_{i j}=\frac{\exp \left(\text { LeakyReLU }\left(\overrightarrow{\mathbf{a}}^{T}\left[\mathbf{W} \vec{h}_{i} \| \mathbf{W} \vec{h}_{j}\right]\right)\right)}{\sum_{k \in N_{i}} \exp \left(\text { LeakyReLU }\left(\overrightarrow{\mathbf{a}}^{T}\left[\mathbf{W} \vec{h}_{i} \| \mathbf{W} \vec{h}_{k}\right]\right)\right)}
$$</code></p>

<p>其中，<code>$\alpha_{i j}$</code> 表示节点 <code>$j$</code> 对 <code>$i$</code> 的注意力系数，<code>$N_i$</code> 表示节点 <code>$i$</code> 的邻居。令 <code>$\mathbf{h}=\left\{\vec{h}_{1}, \vec{h}_{2}, \ldots, \vec{h}_{N}\right\}, \vec{h}_{i} \in \mathbb{R}^{F}$</code> 表示输入节点特征，其中 <code>$N$</code> 为节点的数量，<code>$F$</code> 为特征维度，则节点的输出特征（可能为不同维度 <code>$F^{\prime}$</code>）为 <code>$\mathbf{h}^{\prime}=\left\{\vec{h}_{1}^{\prime}, \vec{h}_{2}^{\prime}, \ldots, \vec{h}_{N}^{\prime}\right\}, \vec{h}_{i}^{\prime} \in \mathbb{R}^{F^{\prime}}$</code>。<code>$\mathbf{W} \in \mathbb{R}^{F^{\prime} \times F}$</code> 为所有节点共享的线性变换的权重矩阵，<code>$a: \mathbb{R}^{F^{\prime}} \times \mathbb{R}^{F^{\prime}} \rightarrow \mathbb{R}$</code> 用于计算注意力系数。最后的输出特征计算方式如下：</p>

<p><code>$$
\vec{h}_{i}^{\prime}=\sigma\left(\sum_{j \in \mathcal{N}_{i}} \alpha_{i j} \mathbf{W} \vec{h}_{j}\right)
$$</code></p>

<p>注意力层采用多头注意力机制来稳定学习过程，之后应用 <code>$K$</code> 个独立的注意力机制计算隐含状态，最后通过拼接或平均得到输出表示：</p>

<p><code>$$
\vec{h}_{i}^{\prime}=\Vert_{k=1}^{K} \sigma\left(\sum_{j \in \mathcal{N}_{i}} \alpha_{i j}^{k} \mathbf{W}^{k} \vec{h}_{j}\right)
$$</code></p>

<p><code>$$
\vec{h}_{i}^{\prime}=\sigma\left(\frac{1}{K} \sum_{k=1}^{K} \sum_{j \in \mathcal{N}_{i}} \alpha_{i j}^{k} \mathbf{W}^{k} \vec{h}_{j}\right)
$$</code></p>

<p>其中，<code>$\Vert$</code> 表示连接操作，<code>$\alpha_{ij}^k$</code> 表示第 <code>$k$</code> 个注意力机制计算得到的标准化的注意力系数。整个模型如下图所示：</p>

<figure>
  <img data-src="/images/cn/2020-04-11-graph-embedding-and-gnn/gat.png" class="lazyload"/>
  
</figure>

<p>GAT 中的注意力架构有如下几个特点：</p>

<ol>
<li>针对节点对的计算是并行的，因此计算过程是高效的。</li>
<li>可以处理不同度的节点并对邻居分配对应的权重。</li>
<li>可以容易地应用到归纳学习问题中去。</li>
</ol>

<h3 id="应用">应用</h3>

<p>图神经网络已经被应用在监督、半监督、无监督和强化学习等多个领域。下图列举了 GNN 在不同领域内相关问题中的应用，具体模型论文请参考 Graph Neural Networks: A Review of Methods and Applications 原文 <sup class="footnote-ref" id="fnref:zhou2018graph"><a href="#fn:zhou2018graph">19</a></sup>。</p>

<figure>
  <img data-src="/images/cn/2020-04-11-graph-embedding-and-gnn/applications.png" class="lazyload"/>
  
</figure>

<h2 id="开放资源">开放资源</h2>

<h3 id="开源实现">开源实现</h3>

<table>
<thead>
<tr>
<th>项目</th>
<th>框架</th>
</tr>
</thead>

<tbody>
<tr>
<td><a href="https://github.com/rusty1s/pytorch_geometric" rel="noreferrer" target="_blank">rusty1s/pytorch_geometric</a></td>
<td><i class="icon icon-pytorch">PyTorch</i></td>
</tr>

<tr>
<td><a href="https://github.com/dmlc/dgl" rel="noreferrer" target="_blank">dmlc/dgl</a></td>
<td><i class="icon icon-pytorch">PyTorch</i>, <i class="icon icon-tensorflow">TF</i> &amp; <i class="icon icon-mxnet">MXNet</i></td>
</tr>

<tr>
<td><a href="https://github.com/alibaba/euler" rel="noreferrer" target="_blank">alibaba/euler</a></td>
<td><i class="icon icon-tensorflow">TF</i></td>
</tr>

<tr>
<td><a href="https://github.com/alibaba/graph-learn" rel="noreferrer" target="_blank">alibaba/graph-learn</a></td>
<td><i class="icon icon-tensorflow">TF</i></td>
</tr>

<tr>
<td><a href="https://github.com/deepmind/graph_nets" rel="noreferrer" target="_blank">deepmind/graph_nets</a></td>
<td><i class="icon icon-tensorflow">TF</i> &amp; <i class="icon icon-sonnet">Sonnet</i></td>
</tr>

<tr>
<td><a href="https://github.com/facebookresearch/PyTorch-BigGraph" rel="noreferrer" target="_blank">facebookresearch/PyTorch-BigGraph</a></td>
<td><i class="icon icon-pytorch">PyTorch</i></td>
</tr>

<tr>
<td><a href="https://github.com/tencent/plato" rel="noreferrer" target="_blank">tencent/plato</a></td>
<td></td>
</tr>

<tr>
<td><a href="https://github.com/PaddlePaddle/PGL" rel="noreferrer" target="_blank">PaddlePaddle/PGL</a></td>
<td><i class="icon icon-paddlepaddle"></i> PaddlePaddle</td>
</tr>

<tr>
<td><a href="https://github.com/Accenture/AmpliGraph" rel="noreferrer" target="_blank">Accenture/AmpliGraph</a></td>
<td><i class="icon icon-tensorflow">TF</i></td>
</tr>

<tr>
<td><a href="https://github.com/danielegrattarola/spektral" rel="noreferrer" target="_blank">danielegrattarola/spektral</a></td>
<td><i class="icon icon-tensorflow">TF</i></td>
</tr>

<tr>
<td><a href="https://github.com/THUDM/cogdl/" rel="noreferrer" target="_blank">THUDM/cogdl</a></td>
<td><i class="icon icon-pytorch">PyTorch</i></td>
</tr>

<tr>
<td><a href="https://github.com/DeepGraphLearning/graphvite" rel="noreferrer" target="_blank">DeepGraphLearning/graphvite</a></td>
<td><i class="icon icon-pytorch">PyTorch</i></td>
</tr>
</tbody>
</table>

<h3 id="论文列表和评测">论文列表和评测</h3>

<ul>
<li><a href="https://github.com/thunlp/NRLPapers" rel="noreferrer" target="_blank">Must-read papers on network representation learning (NRL) / network embedding (NE)</a></li>
<li><a href="https://github.com/thunlp/GNNPapers" rel="noreferrer" target="_blank">Must-read papers on graph neural networks (GNN)</a></li>
<li><a href="https://github.com/DeepGraphLearning/LiteratureDL4Graph" rel="noreferrer" target="_blank">DeepGraphLearning/LiteratureDL4Graph</a></li>
<li><a href="https://github.com/nnzhan/Awesome-Graph-Neural-Networks" rel="noreferrer" target="_blank">nnzhan/Awesome-Graph-Neural-Networks</a></li>
<li><a href="https://github.com/graphdeeplearning/benchmarking-gnns" rel="noreferrer" target="_blank">graphdeeplearning/benchmarking-gnns</a></li>
<li><a href="https://ogb.stanford.edu/" rel="noreferrer" target="_blank">Open Graph Benchmark</a></li>
</ul>
<div class="footnotes">

<hr />

<ol>
<li id="fn:cai2018comprehensive">Cai, H., Zheng, V. W., &amp; Chang, K. C. C. (2018). A comprehensive survey of graph embedding: Problems, techniques, and applications. <em>IEEE Transactions on Knowledge and Data Engineering</em>, 30(9), 1616-1637.
 <a class="footnote-return" href="#fnref:cai2018comprehensive">↩</a></li>
<li id="fn:goyal2018graph">Goyal, P., &amp; Ferrara, E. (2018). Graph embedding techniques, applications, and performance: A survey. <em>Knowledge-Based Systems</em>, 151, 78-94.
 <a class="footnote-return" href="#fnref:goyal2018graph">↩</a></li>
<li id="fn:hamilton2017representation">Hamilton, W. L., Ying, R., &amp; Leskovec, J. (2017). Representation learning on graphs: Methods and applications. <em>arXiv preprint arXiv:1709.05584</em>.
 <a class="footnote-return" href="#fnref:hamilton2017representation">↩</a></li>
<li id="fn:perozzi2014deepwalk">Perozzi, B., Al-Rfou, R., &amp; Skiena, S. (2014). Deepwalk: Online learning of social representations. In <em>Proceedings of the 20th ACM SIGKDD international conference on Knowledge discovery and data mining</em> (pp. 701-710).
 <a class="footnote-return" href="#fnref:perozzi2014deepwalk">↩</a></li>
<li id="fn:grover2016node2vec">Grover, A., &amp; Leskovec, J. (2016). node2vec: Scalable feature learning for networks. In <em>Proceedings of the 22nd ACM SIGKDD international conference on Knowledge discovery and data mining</em> (pp. 855-864).
 <a class="footnote-return" href="#fnref:grover2016node2vec">↩</a></li>
<li id="fn:fogaras2005towards">Fogaras, D., Rácz, B., Csalogány, K., &amp; Sarlós, T. (2005). Towards scaling fully personalized pagerank: Algorithms, lower bounds, and experiments. <em>Internet Mathematics</em>, 2(3), 333-358.
 <a class="footnote-return" href="#fnref:fogaras2005towards">↩</a></li>
<li id="fn:haveliwala2002topic">Haveliwala, T. H. (2002). Topic-sensitive PageRank. In <em>Proceedings of the 11th international conference on World Wide Web</em> (pp. 517-526).
 <a class="footnote-return" href="#fnref:haveliwala2002topic">↩</a></li>
<li id="fn:cao2015grarep">Cao, S., Lu, W., &amp; Xu, Q. (2015). Grarep: Learning graph representations with global structural information. In <em>Proceedings of the 24th ACM international on conference on information and knowledge management</em> (pp. 891-900).
 <a class="footnote-return" href="#fnref:cao2015grarep">↩</a></li>
<li id="fn:ou2016asymmetric">Ou, M., Cui, P., Pei, J., Zhang, Z., &amp; Zhu, W. (2016). Asymmetric transitivity preserving graph embedding. In <em>Proceedings of the 22nd ACM SIGKDD international conference on Knowledge discovery and data mining</em> (pp. 1105-1114).
 <a class="footnote-return" href="#fnref:ou2016asymmetric">↩</a></li>
<li id="fn:dong2017metapath2vec">Dong, Y., Chawla, N. V., &amp; Swami, A. (2017). metapath2vec: Scalable representation learning for heterogeneous networks. In <em>Proceedings of the 23rd ACM SIGKDD international conference on knowledge discovery and data mining</em> (pp. 135-144).
 <a class="footnote-return" href="#fnref:dong2017metapath2vec">↩</a></li>
<li id="fn:fu2017hin2vec">Fu, T. Y., Lee, W. C., &amp; Lei, Z. (2017). Hin2vec: Explore meta-paths in heterogeneous information networks for representation learning. In <em>Proceedings of the 2017 ACM on Conference on Information and Knowledge Management</em> (pp. 1797-1806).
 <a class="footnote-return" href="#fnref:fu2017hin2vec">↩</a></li>
<li id="fn:wang2016structural">Wang, D., Cui, P., &amp; Zhu, W. (2016). Structural deep network embedding. In <em>Proceedings of the 22nd ACM SIGKDD international conference on Knowledge discovery and data mining</em> (pp. 1225-1234).
 <a class="footnote-return" href="#fnref:wang2016structural">↩</a></li>
<li id="fn:cao2016deep">Cao, S., Lu, W., &amp; Xu, Q. (2016). Deep neural networks for learning graph representations. In <em>Thirtieth AAAI conference on artificial intelligence</em>.
 <a class="footnote-return" href="#fnref:cao2016deep">↩</a></li>
<li id="fn:tang2015line">Tang, J., Qu, M., Wang, M., Zhang, M., Yan, J., &amp; Mei, Q. (2015). Line: Large-scale information network embedding. In <em>Proceedings of the 24th international conference on world wide web</em> (pp. 1067-1077).
 <a class="footnote-return" href="#fnref:tang2015line">↩</a></li>
<li id="fn:walker1974new">Walker, A. J. (1974). New fast method for generating discrete random numbers with arbitrary frequency distributions. <em>Electronics Letters</em>, 10(8), 127-128.
 <a class="footnote-return" href="#fnref:walker1974new">↩</a></li>
<li id="fn:walker1977efficient">Walker, A. J. (1977). An efficient method for generating discrete random variables with general distributions. <em>ACM Transactions on Mathematical Software (TOMS)</em>, 3(3), 253-256.
 <a class="footnote-return" href="#fnref:walker1977efficient">↩</a></li>
<li id="fn:zhang2020deep">Zhang, Z., Cui, P., &amp; Zhu, W. (2020). Deep learning on graphs: A survey. <em>IEEE Transactions on Knowledge and Data Engineering</em>.
 <a class="footnote-return" href="#fnref:zhang2020deep">↩</a></li>
<li id="fn:wu2020comprehensive">Wu, Z., Pan, S., Chen, F., Long, G., Zhang, C., &amp; Philip, S. Y. (2020). A comprehensive survey on graph neural networks. <em>IEEE Transactions on Neural Networks and Learning Systems</em>.
 <a class="footnote-return" href="#fnref:wu2020comprehensive">↩</a></li>
<li id="fn:zhou2018graph">Zhou, J., Cui, G., Zhang, Z., Yang, C., Liu, Z., Wang, L., &hellip; &amp; Sun, M. (2018). Graph neural networks: A review of methods and applications. <em>arXiv preprint arXiv:1812.08434</em>.
 <a class="footnote-return" href="#fnref:zhou2018graph">↩</a></li>
<li id="fn:liu2020introduction">Liu, Z., &amp; Zhou, J. (2020). Introduction to Graph Neural Networks. <em>Synthesis Lectures on Artificial Intelligence and Machine Learning</em>, 14(2), 1–127.
 <a class="footnote-return" href="#fnref:liu2020introduction">↩</a></li>
<li id="fn:scarselli2008graph">Scarselli, F., Gori, M., Tsoi, A. C., Hagenbuchner, M., &amp; Monfardini, G. (2008). The graph neural network model. <em>IEEE Transactions on Neural Networks</em>, 20(1), 61-80.
 <a class="footnote-return" href="#fnref:scarselli2008graph">↩</a></li>
<li id="fn:khamsi2011introduction">Khamsi, M. A., &amp; Kirk, W. A. (2011). <em>An introduction to metric spaces and fixed point theory</em> (Vol. 53). John Wiley &amp; Sons.
 <a class="footnote-return" href="#fnref:khamsi2011introduction">↩</a></li>
<li id="fn:defferrard2016convolutional">Defferrard, M., Bresson, X., &amp; Vandergheynst, P. (2016). Convolutional neural networks on graphs with fast localized spectral filtering. In <em>Advances in neural information processing systems</em> (pp. 3844-3852).
 <a class="footnote-return" href="#fnref:defferrard2016convolutional">↩</a></li>
<li id="fn:kipf2016semi">Kipf, T. N., &amp; Welling, M. (2016). Semi-supervised classification with graph convolutional networks. <em>arXiv preprint arXiv:1609.02907</em>.
 <a class="footnote-return" href="#fnref:kipf2016semi">↩</a></li>
<li id="fn:duvenaud2015convolutional">Duvenaud, D. K., Maclaurin, D., Iparraguirre, J., Bombarell, R., Hirzel, T., Aspuru-Guzik, A., &amp; Adams, R. P. (2015). Convolutional networks on graphs for learning molecular fingerprints. In <em>Advances in neural information processing systems</em> (pp. 2224-2232).
 <a class="footnote-return" href="#fnref:duvenaud2015convolutional">↩</a></li>
<li id="fn:atwood2016diffusion">Atwood, J., &amp; Towsley, D. (2016). Diffusion-convolutional neural networks. In <em>Advances in neural information processing systems</em> (pp. 1993-2001).
 <a class="footnote-return" href="#fnref:atwood2016diffusion">↩</a></li>
<li id="fn:hamilton2017inductive">Hamilton, W., Ying, Z., &amp; Leskovec, J. (2017). Inductive representation learning on large graphs. In <em>Advances in neural information processing systems</em> (pp. 1024-1034).
 <a class="footnote-return" href="#fnref:hamilton2017inductive">↩</a></li>
<li id="fn:li2015gated">Li, Y., Tarlow, D., Brockschmidt, M., &amp; Zemel, R. (2015). Gated graph sequence neural networks. <em>arXiv preprint arXiv:1511.05493.</em>
 <a class="footnote-return" href="#fnref:li2015gated">↩</a></li>
<li id="fn:tai2015improved">Tai, K. S., Socher, R., &amp; Manning, C. D. (2015). Improved Semantic Representations From Tree-Structured Long Short-Term Memory Networks. In <em>Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference on Natural Language Processing</em> (Volume 1: Long Papers) (pp. 1556-1566).
 <a class="footnote-return" href="#fnref:tai2015improved">↩</a></li>
<li id="fn:peng2017cross">Peng, N., Poon, H., Quirk, C., Toutanova, K., &amp; Yih, W. T. (2017). Cross-sentence n-ary relation extraction with graph lstms. <em>Transactions of the Association for Computational Linguistics</em>, 5, 101-115.
 <a class="footnote-return" href="#fnref:peng2017cross">↩</a></li>
<li id="fn:velickovic2017graph">Veličković, P., Cucurull, G., Casanova, A., Romero, A., Lio, P., &amp; Bengio, Y. (2017). Graph attention networks. <em>arXiv preprint arXiv:1710.10903.</em>
 <a class="footnote-return" href="#fnref:velickovic2017graph">↩</a></li>
</ol>
</div>



<link rel="stylesheet" href="/css/donate.css" />


<div class="donate">
  <div class="donate-header"></div>
  <div class="donate-slug" id="donate-slug">graph-embedding-and-gnn</div>
  <button class="donate-button">赞 赏</button>
  <div class="donate-footer">「真诚赞赏，手留余香」</div>
</div>
<div class="donate-modal-wrapper">
  <div class="donate-modal">
    <div class="donate-box">
      <div class="donate-box-content">
        <div class="donate-box-content-inner">
          <div class="donate-box-header">「真诚赞赏，手留余香」</div>
          <div class="donate-box-body">
            <div class="donate-box-money">
              <button class="donate-box-money-button donate-box-money-button-unchecked" id="donate-box-money-button-2" data-v="2" data-unchecked="￥ 2" data-checked="2 元">￥ 2</button>
              <button class="donate-box-money-button donate-box-money-button-unchecked" id="donate-box-money-button-5" data-v="5" data-unchecked="￥ 5" data-checked="5 元">￥ 5</button>
              <button class="donate-box-money-button donate-box-money-button-unchecked" id="donate-box-money-button-10" data-v="10" data-unchecked="￥ 10" data-checked="10 元">￥ 10</button>
              <button class="donate-box-money-button donate-box-money-button-unchecked" id="donate-box-money-button-50" data-v="50" data-unchecked="￥ 50" data-checked="50 元">￥ 50</button>
              <button class="donate-box-money-button donate-box-money-button-unchecked" id="donate-box-money-button-100" data-v="100" data-unchecked="￥ 100" data-checked="100 元">￥ 100</button>
              <button class="donate-box-money-button donate-box-money-button-unchecked" id="donate-box-money-button-custom" data-v="custom" data-unchecked="任意金额" data-checked="任意金额">任意金额</button>
            </div>
            <div class="donate-box-pay">
              <img class="donate-box-pay-qrcode" id="donate-box-pay-qrcode" src=""/>
            </div>
          </div>
          <div class="donate-box-footer">
            <div class="donate-box-pay-method donate-box-pay-method-checked" data-v="wechat-pay">
              <img class="donate-box-pay-method-image" id="donate-box-pay-method-image-wechat-pay" src=""/>
            </div>
            <div class="donate-box-pay-method" data-v="alipay">
              <img class="donate-box-pay-method-image"  id="donate-box-pay-method-image-alipay" src=""/>
            </div>
          </div>
        </div>
      </div>
    </div>
    <button type="button" class="donate-box-close-button">
      <svg class="donate-box-close-button-icon" fill="#fff" viewBox="0 0 24 24" width="24" height="24"><path d="M13.486 12l5.208-5.207a1.048 1.048 0 0 0-.006-1.483 1.046 1.046 0 0 0-1.482-.005L12 10.514 6.793 5.305a1.048 1.048 0 0 0-1.483.005 1.046 1.046 0 0 0-.005 1.483L10.514 12l-5.208 5.207a1.048 1.048 0 0 0 .006 1.483 1.046 1.046 0 0 0 1.482.005L12 13.486l5.207 5.208a1.048 1.048 0 0 0 1.483-.006 1.046 1.046 0 0 0 .005-1.482L13.486 12z" fill-rule="evenodd"></path></svg>
    </button>
  </div>
</div>

<script type="text/javascript" src="/js/donate.js"></script>
</script>


  <footer>
  
<nav class="post-nav">
  <span class="nav-prev">&larr; <a href="/cn/2020/03/pre-trained-model-for-nlp/">预训练自然语言模型 (Pre-trained Models for NLP)</a></span>
  <span class="nav-next"><a href="/cn/2020/05/hmm-crf-and-sequence-labeling/">隐马尔可夫 (Hidden Markov Model, HMM)，条件随机场 (Conditional Random Fields, CRF) 和序列标注 (Sequence Labeling)</a> &rarr;</span>
</nav>
<script type="text/javascript">
document.addEventListener('keyup', function(e) {
  if (e.target.nodeName.toUpperCase() != 'BODY') return;
  var url = false;
  if (e.which == 37) {  
    
    url = '\/cn\/2020\/03\/pre-trained-model-for-nlp\/';
    
  } else if (e.which == 39) {  
    
    url = '\/cn\/2020\/05\/hmm-crf-and-sequence-labeling\/';
    
  }
  if (url) window.location = url;
});
</script>




<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-2608165017777396"
     data-ad-slot="1261604535"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>





<section class="comments">
  <div id="disqus_thread"></div>
  <script>
  var disqus_config = function () {
  
    this.page.url = "https:\/\/zeqiang.fun" + location.pathname;
  
  };
  (function() {
    var inIFrame = function() {
      var iframe = true;
      try { iframe = window.self !== window.top; } catch (e) {}
      return iframe;
    };
    if (inIFrame()) return;
    var disqus_js = '//Zeqiang.disqus.com/embed.js';
    var d = document, s = d.createElement('script');
    s.src = disqus_js; s.async = true;
    s.setAttribute('data-timestamp', +new Date());
    var t = d.getElementById('disqus_thread');
    var b = false, l = function(scroll) {
      if (b) return;
      (d.head || d.body).appendChild(s); b = true;
      if (scroll) t.scrollIntoView();
    }
    s.onerror = function(e) {
      if (sessionStorage.getItem('failure-note')) return;
      t.innerText = 'Sorry, but you cannot make comments because Disqus failed to load for some reason. It is known to be blocked in China. If you are sure it is not blocked in your region, please refresh the page. 中国大陆地区读者需要翻墙才能发表评论。';
      sessionStorage.setItem('failure-note', true);
    };
    
    if (location.hash.match(/^#comment-[0-9]+$/)) return l(true);
    var c = function() {
      if (b) return;
      var rect = t.getBoundingClientRect();
      if (rect.top < window.innerHeight && rect.bottom >= 0) l();
    };
    window.addEventListener('load', c);
    d.addEventListener('scroll', c);
  })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</section>




<script async src="/js/fix-toc.js"></script>
<script async src="/js/center-img.js"></script>
<script async src="/js/right-quote.js"></script>
<script async src="/js/fix-footnote.js"></script>
<script async src="/js/external-link.js"></script>
<script async src="/js/alt-title.js"></script>
<script src="/js/no-highlight.js"></script>
<script src="/js/math-code.js"></script>


<script>
window.MathJax = {
  loader: {
    load: ['[tex]/boldsymbol']
  },
  tex: {
    tags: "all",
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$']],
    processEscapes: true,
    processEnvironments: true,
    packages: {
      '[+]': ['boldsymbol']
    }
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.0/es5/tex-chtml.js" crossorigin></script>







<script async src="/js/load-typekit.js"></script>

<script src="//cdnjs.cloudflare.com/ajax/libs/lazysizes/5.3.2/lazysizes.min.js"></script>

<script src="//cdn.jsdelivr.net/npm/vanilla-back-to-top@latest/dist/vanilla-back-to-top.min.js"></script>
<script>
addBackToTop({
  diameter: 48
})
</script>



  <hr>
  <div class="copyright no-border-bottom">
    <div class="copyright-author-year">
      <span>&copy; 2017-2021 Leo Van</span>
    </div>
    <div class="copyright-links">
      <a href="https://github.com/leovan" rel="noreferrer" target="_blank">Github</a>
      <span> · </span>
      <a href="https://orcid.org/0000-0002-9556-7821" rel="noreferrer" target="_blank">ORCID</a>
      <span> · </span>
      <span>I am Mr. Black.</span>
    </div>
  </div>
  </footer>
  </article>
  </body>
</html>

